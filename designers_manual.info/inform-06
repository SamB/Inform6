This is Info file inform.info, produced by Makeinfo-1.64 from the input
file inform.texi.

This is the Inform Designer's Manual, third edition, 4 September 1996.
It was converted to Info by Christopher J. Madsen <ac608@yfn.ysu.edu>.

Copyright 1996 Graham Nelson and Christopher J. Madsen

Permission is granted to make and distribute copies of this manual
provided that:
 (a) distributed copies are not substantially different from those
     archived by the author,
 (b) this and other copyright messages are always retained in full, and
 (c) no profit is involved.


File: inform,  Node: Switchable Objects,  Next: Things to Enter,  Prev: Doors,  Up: The Model World

Switchable objects
==================

     Steven: `Well, what does this do?'
     Doctor: `That is the dematerialising control.  And that over
     yonder is the horizontal hold.  Up there is the scanner, these are
     the doors, that is a chair with a panda on it.  Sheer poetry, dear
     boy.  Now please stop bothering me.'

     -- Dennis Spooner, The Time Meddler
     Dr Who, serial  17 (1965)

Objects can also be switchable.  This means they can be turned off or
on, as if they had some kind of switch on them.  The object has the
attribute on if it's on.  For example:

Object searchlight "Gotham City searchlight" skyscraper
  with name "search" "light" "template", article "the",
       description "It has some kind of template on it.",
       when_on "The old city searchlight shines out a bat against
                the feather-clouds of the darkening sky.",
       when_off "The old city searchlight, neglected but still
                 functional, sits here."
  has  switchable static;

Something more portable would come in handy for the explorer of
`Ruins', who would hardly have embarked on his expedition without a
decent light source...

Object sodium_lamp "sodium lamp"
  with name "sodium" "lamp" "heavy",
       describe
       [;  if (self hasnt on)
               "^The sodium lamp squats heavily on the ground.";
          "^The sodium lamp squats on the ground, burning away.";
       ],
       battery_power 40,
       before
       [;  Examine: print "It is a heavy-duty archaeologist's lamp, ";
               if (self hasnt on) "currently off.";
               if (self.battery_power < 10) "glowing a dim yellow.";
               "blazing with brilliant yellow light.";
           Burn: <<SwitchOn self>>;
           SwitchOn:
               if (self.battery_power <= 0)
                  "Unfortunately, the battery seems to be dead.";
               if (parent(self) hasnt supporter && self notin location)
                  "The lamp must be securely placed before being lit.";
           Take, Remove:
               if (self has on)
                  "The bulb's too delicate and the metal frame's too
                   hot to lift the lamp while it's switched on.";
       ],
       after
       [;  SwitchOn: give self light;
           SwitchOff: give self ~light;
       ],
  has  switchable;

The `Ruins' lamp will eventually be a little more complicated, with a
daemon to make the battery power run down and to extinguish the lamp
when it runs out; and it will be pushable from place to place, making it
not quite as useless as the player will hopefully think at first.

!! A point to note is that this time the when_on and when_off
properties haven't been used to describe the lamp when it's on the
ground: this is because once an object has been held by the player,
it's normally given only a perfunctory mention in room descriptions
("You can also see a sodium lamp and a grape here.").  But the describe
property has priority over the whole business of how objects are
described in room descriptions.  When it returns true, as above, the
usual description process does nothing further.  For much more on room
descriptions, see *Note Describing Objects::.

References
----------

   * The original switchable object was the brass lamp from `Advent'
     (which also provides verbs "on" and "off" to switch it).  (The
     other example games are generally pre-electric in setting.)


File: inform,  Node: Things to Enter,  Next: Reading Matter,  Prev: Switchable Objects,  Up: The Model World

Things to enter, travel in and push around
==========================================

     ...the need to navigate a newly added river prompted the invention
     of vehicles (specifically, a boat).

     -- P. David Lebling, Marc Blank and Timothy Anderson

Some objects in a game are enterable, which means that a player can get
inside or onto them.  The idea of "inside" here is that the player is
only half-in, as with a car or a psychiatrist's couch.  (If it's more
like a prison cell, then it should be a separate place.)  In practice
one often wants to make an enterable thing also a container, or, as in
the altar from `Ruins', a supporter:

Object -> stone_table "slab altar"
 with name "stone" "table" "slab" "altar" "great",
      initial "A great stone slab of a table, or altar, dominates the Shrine.",
 has  enterable supporter;

A chair to sit on, or a bed to lie down on, should also be a supporter.

Exercise 14
-----------

   (Also from `Ruins'.)  Implement a cage which can be opened, closed
and entered.

   *Note Answer 14::

All the classic games have vehicles (like boats, or fork lift trucks, or
hot air balloons) which the player can journey in, so Inform makes this
easy.  Here is a simple case:

Object car "little red car" cave
  with name "little" "red" "car",
       description "Large enough to sit inside.  Among the controls is a
           prominent on/off switch.  The numberplate is KAR 1.",
       when_on  "The red car sits here, its engine still running.",
       when_off "A little red car is parked here.",
       before
       [; Go: if (car has on) "Brmm!  Brmm!";
              print "(The ignition is off at the moment.)^";
       ],
  has  switchable enterable static container open;

Actually, this demonstrates a special rule.  If a player is inside an
enterable object and tries to move, say "north", the before routine for
the object is called with the action Go, and n_obj as the noun.  It may
then return:

     0    to disallow the movement, printing a refusal;
     1    to allow the movement, moving vehicle and player;
     2    to disallow but print and do nothing; or
     3    to allow but print and do nothing.

If you want to move the vehicle in your own code, return 3, not 2:
otherwise the old location may be restored by subsequent workings.

Because you might want to drive the car "out" of a garage, the "out"
verb does not make the player get out of the car.  Usually the player
has to type something like "get out" to make this happen, though of
course the rules can be changed.

Exercise 15
-----------

   Alter the car so that it won't go east.

   *Note Answer 15::

!!  Objects like the car or, say, an antiquated wireless on casters,
are obviously too heavy to pick up but the player should at least be
able to push them from place to place.  When the player tries to do
this, the PushDir action is generated.  Now, if the before routine
returns false, the game will just say that the player can't; and if it
returns true, the game will do nothing at all, guessing that the before
routine has already printed something more interesting.  So how does
one actually tell Inform that the push should be allowed?  The answer
is that one has to do two things: call the AllowPushDir routine (a
library routine), and then return true.  For example (`Ruins' again):

Object -> huge_ball "huge pumice-stone ball"
  with name "huge" "pumice" "pumice-stone" "stone" "ball",
       description "A good eight feet across, though fairly lightweight.",
       initial
           "A huge pumice-stone ball rests here, eight feet wide.",
       before
       [;  PushDir:
               if (location==Junction && second==w_obj)
                   "The corridor entrance is but seven feet across.";
               AllowPushDir(); rtrue;
           Pull, Push, Turn: "It wouldn't be so very hard to get rolling.";
           Take, Remove: "There's a lot of stone in an eight-foot sphere.";
       ],
       after
       [;  PushDir:
              if (second==s_obj) "The ball is hard to stop once underway.";
              if (second==n_obj) "You strain to push the ball uphill.";
       ],
  has  static;

!! Exercise 16
--------------

The library does not normally allow pushing objects up or down.  How
can the pumice ball allow this?

   *Note Answer 16::

References
----------

   * For an enterable supporter puzzle, see the magic carpet in
     `Balances' (and several items in `Alice Through The
     Looking-Glass').


File: inform,  Node: Reading Matter,  Next: Living Creatures,  Prev: Things to Enter,  Up: The Model World

Reading matter and consultation
===============================

     Even at present... we still know very little about how access to
     printed materials affects human behaviour.

     -- Elizabeth Eisenstein, The Printing Revolution in Early Modern
     Europe

     look up figure 18 in the engineering textbook

is a difficult line for Inform to understand, because almost anything
could appear in the first part: even its format depends on what the
second part is.  This kind of request, and more generally

     look up <any words here> in <the object>
     read about <any words here> in <the object>
     consult <the object> about <any words here>

cause the Consult object action.  Note that second is just zero:
formally, there is no second noun attached to a Consult action.  The
object has to parse the <any words here> part itself, in a before rule
for Consult.  The following variables are set up to make this possible:

  consult_from   the number of the first word in the <any...> clause;
  consult_words  the number of words in the <any...> clause (at least 1).

The words given are parsed using library routines like NextWord(),
TryNumber(word-number) and so on: see *Note Parsing Nouns:: for full
details.  As usual, the before routine should return true if it has
managed to deal with the action; returning false will make the library
print "You discover nothing of interest in...".

   Little hints are placed here and there in the `Ruins', written in
the glyphs of an ancient dialect of Mayan.  Our explorer has, of
course, come equipped with the latest and finest scholarship on the
subject:

Object dictionary "Waldeck's Mayan dictionary"
  with name "dictionary" "local" "guide" "book" "mayan"
            "waldeck" "waldeck^s",
       description "Compiled from the unreliable lithographs of the
           legendary raconteur and explorer ~Count~ Jean Frederic
           Maximilien Waldeck (1766??-1875), this guide contains
           what little is known of the glyphs used in the local
           ancient dialect.",
       before
       [ w1 w2 glyph other;  Consult:
               if (consult_words>2) jump GlyphHelp;
               wn=consult_from;
               w1 = NextWord(); ! First word of subject
               w2 = NextWord(); ! Second word (if any) of subject
               if (consult_words==1 && w1=='glyph' or 'glyphs')
                   jump GlyphHelp;
               !  We want to recognise both "glyph q1" and "q1 glyph":
               glyph=w1; other=w2;
               if (w1=='glyph') { glyph=w2; other=w1; }
               !  So now glyph holds the name, and other the other word
               if (consult_words==2 && other~='glyph') jump GlyphHelp;
               switch(glyph)
               {   'q1': "(This is one glyph you have memorised!)^^
                          Q1: ~sacred site~.";
                   'circle': "Circle: ~the Sun; also life, lifetime~.";
                   ...
                   default: "That glyph is so far unrecorded.";
               }
               !  All three of the ways the text can go wrong lead to
               !  this message being produced:
              .GlyphHelp; "Try ~look up <name of glyph> in book~.";
       ],
  has  proper;

Note that this understands any of the forms "q1", "glyph q1" or "q1
glyph" but is careful to reject, for instance, "glyph q1 glyph".
(These aren't genuine Mayan glyphs, but some of the real ones have
similar names, dating from when their syllabic equivalents weren't
known: G8, the Lord of the Night, for instance.)

Exercise 17
-----------

   To mark the 500th anniversary of William Tyndale (the first English
translator of the New Testament), prepare an edition of the four
Gospels.

   *Note Answer 17::

!!!!  Ordinarily, a request by the player to "read" something is
translated into an Examine action.  But the "read" verb is defined
independently of the "examine" verb in order to make it easy to
separate the two requests.  For instance:

Attribute legible;
...
Object textbook "textbook"
  with name "engineering" "textbook" "text" "book",
       description "What beautiful covers and spine!",
       before
       [; Consult, Read:
           "The pages are full of senseless equations.";
       ],
       has  legible;
...
[ ReadSub; <<Examine noun>>; ];
Extend "read" first * legible                        -> Read;

Note that "read" causes a Read action only for legible objects, and
otherwise causes Examine in the usual way.  ReadSub is coded as a
translation to Examine as well, so that if a legible object doesn't
provide a Read rule then an Examine happens after all.

References
----------

   * If you really need more elaborate topic-parsing (for, e.g., "look
     up <something> in the catalogue", where any object name might
     appear) then extending the grammar for look may be less trouble.
     For a good implementation see `Encyclopaedia Frobozzica', by
     Gareth Rees.


File: inform,  Node: Living Creatures,  Next: Light and Dark,  Prev: Reading Matter,  Up: The Model World

Living creatures and conversation
=================================

     To know how to live is my trade and my art.
     
     -- Michel de Montaigne (1533-1592), Essays

     Everything that can be said can be said clearly.
     
     -- Ludwig Wittgenstein (1889-1951), Tractatus

This rummage through special kinds of objects finishes up with the most
sophisticated kind: living ones.  Note that the finer points of this
section, on the arts of conversation, require some knowledge of Chapter
V.

   Animate objects, such as sea monsters, mad aunts or nasty little
dwarves, have a property called life.  This behaves somewhat like a
before or after routine, but only applies to the following actions:

Attack
     The player is making hostile advances...

Kiss
     ...or excessively friendly ones...

WakeOther
     ...or simply trying to rouse the creature from sleep.

ThrowAt
     The player asked to throw noun at the creature.

Give
     The player asked to give noun to the creature...

Show
     ...or, tantalisingly, just to show it.

Ask
     The player asked about something.  Just as with a "consult" topic
     (see *Note Reading Matter:: passim), the variables consult_from
     and consult_words are set up to indicate which words the object
     might like to think about.  (In addition, second holds the
     dictionary value for the first word which isn't 'the', but this is
     much cruder.)

Tell
     Likewise, the player is trying to tell the creature about
     something.  The topic is set up just as for Ask (that is,
     consult_from and consult_words are set, and second also holds the
     first interesting word).

Answer
     This can happen in two ways.  One is if the player types "answer
     <some text> to troll" or "say <some text> to troll"; the other is
     if he gives an order which the parser can't sort out, such as
     "troll, og south", and which the orders property hasn't handled
     already.  Once again, variables are set as if it were a "consult"
     topic.  (In addition, noun is set to the first word, and an
     attempt to read the text as a number is stored in the variable
     special_number: for instance, "computer, 143" will cause
     special_number to be set to 143.)

Order
     This catches any `orders' which aren't handled by the orders
     property (see below); action, noun and second are set up as usual.

If the life routine doesn't exist, or returns false, events take their
usual course.  life routines tend to be quite lengthy, even for
relatively static characters such as the priest who stands in the
`Ruins' Shrine:

Object -> priest "mummified priest"
  with name "mummified" "priest",
       description
          "He is desiccated and hangs together only by will-power.  Though
           his first language is presumably local Mayan, you have the curious
           instinct that he will understand your speech.",
       initial "Behind the slab, a mummified priest stands waiting, barely
           alive at best, impossibly venerable.",
       life
       [; Answer: "The priest coughs, and almost falls apart.";
          Ask:     switch(second)
                   {   'dictionary', 'book':
                            if (dictionary has general)
                                "~The ~bird~ glyph... very funny.~";
                           "~A dictionary? Really?~";
                       'glyph', 'glyphs', 'mayan', 'dialect':
                           "~In our culture, the Priests are ever literate.~";
                       'king', 'tomb', 'shrine', 'temple', 'altar', 'slab':
                           "~The King (life! prosperity! happiness!) is buried
                            deep under this Shrine, where you will never go.~";
                   }
                   "~You must find your own answer.~";
          Tell:   "The priest has no interest in your sordid life.";
          Attack, Kiss:  remove self;
                  "The priest desiccates away into dust until nothing
                   remains, not a breeze nor a bone.";
          ThrowAt: move noun to location; <<Attack self>>;
          Show, Give:
                   if (noun==dictionary && dictionary hasnt general)
                   {   give dictionary general;
                      "The priest reads a little of the book, laughing
                       in a hollow, whispering way.  Unable to restrain
                       his mirth, he scratches in a correction somewhere
                       before returning the book.";
                   }
                  "The priest is not very interested in earthly things.";
       ],
  has  animate;

(Some of the Ask topics are omitted for brevity.) Of course an animate
object still has before and after routines like any other, so you can
trap many other kinds of behaviour.  Animate creatures can also
react_before and react_after, and it's here that these properties
really come into their own:

       react_before
       [; Drop: if (noun==satellite_gadget)
             print "~I wouldn't do that, Mr Bond,~ says Blofeld.^^";
          Shoot: remove beretta;
            "As you draw, Blofeld snaps his fingers and a giant
             magnet snatches the gun from your hand.  It hits the
             ceiling with a clang.  Blofeld silkily strokes his cat.";
       ];

If Blofeld moves from place to place, these rules move with him.

Exercise 18
-----------

   Arrange for a bearded psychiatrist to place the player under
observation, occasionally mumbling insights such as "Subject puts green
cone on table.  Interesting."

   *Note Answer 18::

Another example is the coiled snake from `Balances', which shows that
even the tiniest life routine can be adequate for an animal:

Object -> snake "hissing snake"
  with name "hissing" "snake",
       initial "Tightly coiled at the edge of the chasm is a hissing snake.",
       life [; "The snake hisses angrily!"; ],
  has  animate;

!! When writing general code to deal with animate creatures, it's
sometimes convenient to have a system worked out for printing pronouns
such as "her" and "He".  See *Note Describing Objects:: for one way to
do this.

Sometimes creatures should be transparent, sometimes not.  Consider
these two cases of animate characters, for instance:

   * an urchin with something bulging inside his jacket pocket;

   * a hacker who has a bunch of keys hanging off his belt.

The hacker is transparent, the urchin not.  That way the parser prevents
the player from referring to whatever the urchin is hiding, even if the
player has played the game before, and knows what is in there and what
it's called.  But the player can look at and be tantalised by the
hacker's keys.

When the player types in something like "pilot, fly south", the result
is called an `order': this is the corresponding idea to an `action'.
(Indeed, if the player types "me, go south" an ordinary Go s_obj action
is produced.)

   The order is sent to the pilot's orders property, which may if it
wishes obey or react in some other way.  Otherwise, the standard game
rules will simply print something like "The pilot has better things to
do."  The above priest is especially unhelpful:

       orders
       [;  Go: "~I must not leave the Shrine.~";
           NotUnderstood: "~You speak in riddles.~";
           default: "~It is not your orders I serve.~";
       ];

(The NotUnderstood clause is run when the parser couldn't understand
what the player typed: e.g., "priest, go onrth".)

!! Something to bear in mind is that because the library regards the
words "yes" and "no" as being verbs in Inform, it understands "delores,
yes" as being a Yes order.  (This can be a slight nuisance, as "say yes
to delores" is treated differently: it gets routed through the life
routine as an Answer.)

!!!! If the orders property returns false (or if there wasn't an orders
property in the first place), the order is sent either to the Order:
part of the life property (if it's understood) or to the Answer: part
(if it isn't).  (This is how all orders used to be processed, and it's
retained to avoid making reams of old Inform code go wrong.)  If these
also return false, a message like "X has better things to do" or "There
is no reply" is finally printed.

To clarify the various kinds of conversation:

Command                     rule     action    noun      second    consult
"orc, take axe"             order    Take      axe       0
"orc, yes"                  order    Yes       0         0
"ask orc for the shield"    order    Give      shield    player
"orc, troll"                order    NotU...   'troll'   orc       3  1
"say troll to orc"          life     Answer    'troll'   orc       2  1
"answer troll to orc"       life     Answer    'troll'   orc       2  1
"orc, tell me about coins"  life     Ask       orc       'coins'   6  1
"ask orc about the big troll" life   Ask       orc       'big'     4  3
"ask orc about wyvern"      life     Ask       orc       0         4  1
"tell orc about lost troll" life     Tell      orc       'lost'    4  2

where "wyvern" is a word not mentioned anywhere in the program, which
is why its value is 0.

Exercise 19
-----------

   In some ways, Answer and Tell are just too much trouble.  How can
you make attempts to use these produce a message saying "To talk to
someone, try `someone, something'."?

   *Note Answer 19::

Some objects are not alive as such, but can be spoken to: microphones,
tape recorders, voice-activated computers and so on.  It would be a
nuisance to implement these as animate, since they have none of the
other characteristics of life: instead, they can be given just the
attribute talkable and orders and life properties to deal with the
resulting conversation.

Exercise 20
-----------

   (Cf. `Starcross'.)  Construct a computer responding to "computer,
theta is 180".

   *Note Answer 20::

!! The rest of this section starts to overlap much more with Chapter V,
and assumes a little familiarity with the parser.

!! The NotUnderstood clause of orders is run when the parser has got
stuck parsing an order like "pilot, fly somersaults".  The variable
etype holds the parser error that would have been printed out, had it
been a command by the player himself.  See *Note Helping the Parser:::
for instance, CANTSEE_PE would mean "the pilot can't see any such
object".

!!  When the player issues requests to an animate or talkable object,
they're normally parsed exactly as if they were commands by the player
himself (except that the actor is now the person being spoken to).  But
sometimes one would rather they were parsed by an entirely different
grammar.  For instance, consider Zen, the flight computer of an alien
spacecraft.  It's inappropriate to tell Zen to (say) pick up a teleport
bracelet and the crew tend to give commands more like:

     ``Zen, set course for Centauro''
     ``Zen, speed standard by six''
     ``Zen, scan 360 orbital''
     ``Zen, raise the force wall''
     ``Zen, clear the neutron blasters for firing''

This could mostly be implemented by adding verbs like "raise" to the
usual game grammar (see the `Starcross' computer exercise above), or by
carefully trapping the Answer rule.  But this is a nuisance, especially
if about half the commands you want are recognised as orders in the
usual grammar but the other half aren't.

   An animate or talkable object can therefore provide a grammar
routine (if it likes).  This is called at a time when the parser has
worked out the object that is being addressed and has set the variables
verb_num and verb_word (to the number of the `verb' and its dictionary
entry, respectively: for example, in "orac, operate the teleport"
verb_num would be 3 (because the comma counts as a word on its own) and
verb_word would be 'operate').  The grammar routine can reply by
returning:

0.
     The parser carries on as usual.

1.
     The grammar routine is saying it has done all the parsing necessary
     itself, by hand (i.e., using NextWord, TryNumber, NounDomain and
     the like): the variables action, noun and second must be set up to
     contain the resulting order.

'verb'
     The parser ignores the usual grammar and instead works through the
     grammar lines for the given verb (see below).

-'verb'
     Ditto, except that if none of those grammar lines work then the
     parser goes back and tries the usual grammar as well.

In addition, the grammar routine is free to do some partial parsing of
the early words provided it moves on verb_num accordingly to show how
much it's got through.

!! Exercise 21
--------------

   Implement Charlotte, a little girl who's playing Simon Says (a game
in which she only follows your instructions if you remember to say
"Simon says" in front of them: so she'll disobey "charlotte, wave" but
obey "charlotte, simon says wave").

   *Note Answer 21::

!! Exercise 22
--------------

   Another of Charlotte's rules is that if you say a number, she has to
clap that many times.  Can you play?

   *Note Answer 22::

!! Exercise 23
--------------

   Regrettably, Dyslexic Dan has always mixed up the words "take" and
"drop".  Implement him anyway.

   *Note Answer 23::

!! It's useful to know that if the player types a comma or a full stop,
then the parser cuts these out as separate words.  Because of this, a
dictionary word containing up to 7 letters and then a comma or a full
stop can never be matched by what the player types.  Such a word is
called an "untypeable verb", and it's useful to help a grammar routine
to shunt parsing into a piece of game grammar which the player can
never use.  For instance, here's a way to implement the `Starcross'
computer which doesn't involve creating foolish new actions.  We create
grammar:

[ Control;
  switch(NextWord())
  {   'theta': parsed_number=1; return 1;
      'phi':   parsed_number=2; return 1;
      'range': parsed_number=3; return 1;
      default: return -1;
  }
];
Verb "comp," * Control "is" number -> SetTo;

And the computer itself needs properties

       grammar [; return 'comp,'; ],
       orders
       [;  SetTo:
               switch(noun)
               {   1: print "~Theta"; 2: print "~Phi"; 3: print "~Range"; }
               print_ret " set to ", second, ".~";
           default: "~Does not compute!~";
       ];

This may not look easier, but it's much more flexible, as the exercises
below will hopefully demonstrate.

!!!! Another use for untypeable verbs is to create what might be called
`fake fake actions'.  Recall that a fake action is one which is never
generated by the parser, and has no action routine.  Sometimes (very
rarely) you want a proper action but which still can't be generated by
the parser: the following example creates three.

Verb "actions." * -> Prepare * -> Simmer * -> Cook;

The parser never uses "actions." in its ordinary grammar, so this
definition has the sole effect of creating three new actions: Prepare,
Simmer and Cook.

!!!! Exercise 24
----------------

   How can you make a grammar extension to an ordinary verb that will
apply only to Dan?

   *Note Answer 24::

!! Exercise 25
--------------

   Make an alarm clock responding to "alarm, off", "alarm, on" and
"alarm, half past seven" (the latter to set its alarm time).

   *Note Answer 25::

!! Exercise 26
--------------

   Implement a tricorder (from Star Trek) which analyses nearby objects
on a request like "tricorder, the quartz stratum".

   *Note Answer 26::

!! Exercise 27
--------------

   And, for good measure, a replicator responding to commands like
"replicator, tea earl grey" and "replicator, aldebaran brandy".

   *Note Answer 27::

!!!! Exercise 28
----------------

   And a communications badge in contact with the ship's computer,
which answers questions like "computer, where is Admiral Lebling".

   *Note Answer 28::

!!!! Exercise 29
----------------

   Finally, construct the formidable flight computer Zen.

   *Note Answer 29::

The next two exercises really belong to *Note Scope::, but are too
useful (for the "someone on the other end of a phone" situation) to
bury far away.  Note that an alternative to these scope-hacking tricks,
if you just want to implement something like "michael, tell me about
the crystals" (when Michael is at the other end of the line), is to
make the phone a talkable object and make the word 'michael' refer to
the phone (using a parse_name routine).

   For more on scope hacking, see *Note Scope::.  Note that the
variable scope_reason is always set to the constant value
TALKING_REASON when the game is trying to work out who you wish to talk
to: so it's quite easy to make the scope different for conversational
purposes.

!! Exercise 30
--------------

   Via the main screen of the Starship Enterprise, Captain Picard wants
to see and talk to Noslen Maharg, the notorious tyrant, who is down on
the planet Mrofni.  Make it so.

   *Note Answer 30::

!!!! Exercise 31
----------------

   Put the player in telepathic contact with Martha, who is in a sealed
room some distance away, but who has a talent for telekinesis.  Martha
should respond well to "martha, look", "ask martha about...", "say yes
to martha", "ask martha for red ball", "martha, give me the red ball"
and the like.

   *Note Answer 31::

References
----------

   * A much fuller example of a `non-player character' is given in the
     example game `The Thief', by Gareth Rees (though it's really an
     implementation of the gentleman in `Zork', himself an imitation of
     the pirate in `Advent').  The thief is capable of walking around,
     being followed, stealing things, picking locks, opening doors and
     so on.

   * Other good definitions of animate objects to look at are
     Christopher in `Toyshop', who will stack up building blocks on
     request; the kittens in `Alice Through The Looking-Glass'; the
     barker in `Balances', and the cast of `Advent': the little bird,
     the snake, bear and dragon, the pirate and of course the
     threatening little dwarves.

   * Following people means being able to refer to them after they've
     left the room: see `Follow my leader', also by Mr Rees, or the
     library extension "follower.h" by Andrew Clover.

   * See the Inform home page for a way round the Yes awkwardness.

   * orders and grammar are newly introduced into Inform, and so are
     not much seen in existing games.

   * For parsing topics of conversation in advanced ways, see the
     example game `Encyclopaedia Frobozzica' by Gareth Rees.

   * To see how much a good set of characters can do for a game, try
     playing the prologue of `Christminster'.


File: inform,  Node: Light and Dark,  Next: Daemons,  Prev: Living Creatures,  Up: The Model World

The light and the dark
======================

The library maintains light by itself, and copes with events like:

     a total eclipse of the sun;
     fusing all the lights in the house;
     your lamp going out;
     a dwarf stealing it and running away;
     dropping a lit match which you were seeing by;
     putting your lamp into an opaque box and shutting the lid;
     black smoke filling up the glass jar that the lamp is in;
     the dwarf with your lamp running back into your now-dark room.

The point of this list is to demonstrate that light versus darkness is
tricky to get right, and best left to the library.  Your code needs
only to do something like

     give lamp light;
     remove match;
     give glass_jar ~transparent;
     move dwarf to Dark_Room;

and can leave the library to sort out the consequences.  As the above
suggests, the light attribute means that an object is giving off light,
or that a room is currently lit, e.g. because it is outdoors in
day-time.  If you simply never want to have darkness, a sneaky way of
doing it is to put the line

     give player light;

in Initialise.  The game works as if the player herself were glowing
enough to provide light to see by.  So there's never darkness near the
player.

   The definition of "when there is light" is complicated, involving
recursion both up and down.  Remember that the parent of the player
object may not be a room; it may be, say, a red car whose parent is a
room.

*Definition.* There is light exactly when the parent of the player
`offers light'.  An object `offers light' if:

     it itself has the light attribute set, *or*
     any of its immediate possessions `have light', *or*
     it is see-through and its parent offers light, *or*
     it is enterable and its parent offers light;

while an object `has light' if:

     it currently has the light attribute set, *or*
     it is see-through and one of its immediate possessions has light.

The process of checking this stops as soon as light is discovered.  The
routines

     OffersLight(object) and HasLightSource(object)

return true or false and might occasionally be useful.

!! So light is cast up and down the tree of objects.  In certain
contrived circumstances this might be troublesome: perhaps an opaque
box, whose outside is fluorescent but whose interior is dark, and which
contains an actor who needs not to have other contents of the box in
scope...  The dilemma could be solved by putting an inner box in the
outer one.

Exercise 32
-----------

   How would you code a troll who is afraid of the dark, and needs to
be bribed but will only accept a light source... so that the troll will
be as happy with a goldfish bowl containing a fluorescent jellyfish as
he would be with a lamp?

   *Note Answer 32::

Each turn, light is reconsidered.  The presence or absence of light
affects the Look, Search, LookUnder and Examine actions, and (since
this is a common puzzle) also the Go action: you can provide a routine
called

     DarkToDark()

and if you do then it will be called when the player goes from one dark
room into another dark one (just before the room description for the new
dark room, probably "Darkness", is printed).  If you want, you can take
the opportunity to kill the player off or extract some other forfeit.
If you provide no such routine, then the player can move about freely
(subject to any rules which apply in the places concerned).

!! When the player is in darkness, the current location becomes
thedark, a special object which acts like a room and has the short name
"Darkness".  You can change the initial, description or short_name
properties for this.  For example, your Initialise routine might set

    thedark.short_name = "Creepy, nasty darkness";

See *Note Daemons:: for how `Ruins' makes darkness menacing.

!! Exercise 33
--------------

   Implement a pet moth which escapes if it's ever taken into darkness.

   *Note Answer 33::

References
----------

   * For a DarkToDark routine which discourages wandering about caves
     in the dark, see `Advent'.


File: inform,  Node: Daemons,  Next: Player,  Prev: Light and Dark,  Up: The Model World

Daemons and the passing of time
===============================

     Some, such as Sleep and Love, were never human.  From this class
     an individual daemon is allotted to each human being as his
     `witness and guardian' through life.

     -- C. S. Lewis (1898-1963), The Discarded Image

     A great Daemon... Through him subsist all divination, and the
     science of sacred things as it relates to sacrifices, and
     expiations, and disenchantments, and prophecy, and magic... he who
     is wise in the science of this intercourse is supremely happy...\

     -- Plato (c.427-347 BC), `The Symposium'
     -- translated by Percy Bysshe Shelley (1792-1822)

In medieval neo-Platonist philosophy, daemons are the intermediaries of
God, hovering invisibly over the world and interfering with it.  They
may be guardian spirits of places or people.  So, here, a daemon is a
meddling spirit, associated with a particular game object, which gets a
chance to interfere once per turn while it is `active'.  The classic
example is of the dwarves of `Advent', who appear in the cave from time
to time: a daemon routine attached to the dwarf object moves it about,
throws knives at the player and so on.  Each object can have a daemon
routine of its own.  This is set going, and stopped again, by calling
the (library) routines

     StartDaemon(object);
     StopDaemon(object);

Once active, the daemon property of the object is called as a routine
each turn.  Daemons are often started by a game's Initialise routine
and sometimes remain active throughout.  For instance, a lamp-battery
daemon might do something every turn, while others may hide for many
turns before pouncing: such as the daemon in `Advent' which waits until
the player has found all the treasures.

!! In particular, a daemon doesn't stop running just because the player
has moved on to somewhere else.  (Indeed, the library never stops a
daemon unless told to.)  Actually this is very useful, as it means
daemons can be used for `tidying-up operations', or for the
consequences of the player's actions to catch up with him.

Exercise 34
-----------

   Many games contain `wandering monsters', characters who walk around
the map.  Use a daemon to implement one who wanders as freely as the
player, like the gentleman thief in `Zork'.

   *Note Answer 34::

!! Exercise 35
--------------

   Use a background daemon to implement a system of weights, so that
the player can only carry a certain weight before her strength gives
out and she is obliged to drop something.  It should allow for feathers
to be lighter than lawn-mowers.

   *Note Answer 35::

A `timer' (these are traditionally called `fuses') can alternatively be
attached to an object.  "Alternatively" because an object can't have
both a timer and a daemon going at the same time.  A timer is started
with

     StartTimer(object, time);

in which case it will `go off', alarm clock-style, in the given number
of turns.  This means that its time_out property will be called, once
and once only, when the time comes.  The timer can be deactivated (so
that it will never go off) by calling

     StopTimer(object);

A timer is required to provide a time_left property, to hold the amount
of time left.  (If it doesn't, an error message is printed at
run-time.)  You can alter time_left yourself: a value of 0 means `will
go off at the end of this turn', so setting time_left to 0 triggers
immediate activation.

!! Normally, you can only have 32 timers or daemons active at the same
time as each other (plus any number of inactive ones).  But this limit
is easily raised: just define the constant MAX_TIMERS to some larger
value, putting the definition in your code before the Parser file is
included.

There is yet a third form of timed event.  If a room provides an
each_turn routine, then this will be called at the end of each turn
while the player is there; if an object provides each_turn, this is
called while the object is nearby.  For instance, a radio might blare
out music whenever it is nearby; a sword might glow whenever monsters
are nearby; or a stream running through several forest locations might
occasionally float objects by.

   `Each turn' is entirely separate from daemons and timers.  Although
an object can't have both a timer and a daemon at the same time, it can
have an each_turn at the same time, and this is quite useful,
especially to run creatures.  An ogre with limited patience can
therefore have an each_turn routine which worries the player ("The ogre
stamps his feet angrily!", etc.) while also having a timer set to go
off when his patience runs out.

!! `Nearby' actually means `in scope', a term which will be properly
explained later.  The idea is based on line of sight, which works well
in most cases.

!!!! But it does mean that the radio will be inaudible when shut up
inside most containers -- which is arguably fair enough -- yet audible
when shut up inside transparent, say glass, ones.  You can always
change the scope rules using an InScope routine to get around this.  In
case you want to tell whether scope is being worked out for ordinary
parsing reasons or instead for each_turn processing, look at the
scope_reason variable (*note Scope::.).  Powerful effects are available
this way -- you could put the radio in scope within all nearby rooms so
as to allow sound to travel.  Or you could make a thief audible
throughout the maze he is wandering around in, as in `Zork I'.

Exercise 36
-----------

   (Why the `Ruins' are claustrophobic.)  Make "the sound of scuttling
claws" approach the player in darkness and, after 4 consecutive turns
in darkness, kill him.

   *Note Answer 36::

!! Exercise 37
--------------

   A little harder: implement the scuttling claws in a single object
definition, with no associated code anywhere else in the program (not
even a line in Initialise) and without running its daemon all the time.

   *Note Answer 37::

The library also has the (limited) ability to keep track of time of day
as the game goes on.  The current time is held in the variable the_time
and runs on a 24-hour clock: this variable holds minutes since midnight,
so it has values between 0 and 1439.  The time can be set by

     SetTime( 60 * <hours>+<minutes>, <rate> );

The rate controls how rapidly time is moving: a rate of 0 means it is
standing still (that is, that the library doesn't change it: your
routines still can).  A positive rate means that that many minutes pass
between each turn, while a negative rate means that many turns pass
between each minute.  (It's usual for a timed game to start off the
clock by calling SetTime in its Initialise routine.) The time only
(usually) appears on the game's status line if you set

     Statusline time;

as a directive somewhere in your code.

Exercise 38
-----------

   How could you make your game take notice of the time passing
midnight, so that the day of the week could be nudged on?

   *Note Answer 38::

!! Exercise 39
--------------

   (Cf. Sam Hulick's vampire game, `Knight of Ages'.) Make the lighting
throughout the game change at sunrise and sunset.

   *Note Answer 39::

!! Exactly what happens at the end of each turn is:

  1. The turns counter is incremented.

  2. The 24-clock is moved on.

  3. Daemons and timers are run (in no guaranteed order).

  4. each_turn takes place for the current room, and then for
     everything nearby (that is, in scope).

  5. The game's global TimePasses routine is called.

  6. Light is re-considered (it may have changed as a result of events
     since this time last turn).

The sequence is abandoned if at any stage the player dies or wins.

!! Exercise 40
--------------

   Suppose the player is magically suspended in mid-air, but that
anything let go of will fall out of sight.  The natural way to code
this is to use a daemon which gets rid of anything it finds on the
floor (this is better than just trapping Drop actions because objects
might end up on the floor in many different ways).  Why is using
each_turn better?

   *Note Answer 40::

Exercise 41
-----------

   How would a game work if it involved a month-long archaeological
dig, where anything from days to minutes pass between successive game
turns?

   *Note Answer 41::

References
----------

   * Daemons abound in most games.  `Advent' uses them to run down the
     lamp batteries, make the bear follow you, animate the dwarves and
     the pirate and watch for the treasure all being found.  See also
     the flying tortoise from `Balances' and the chiggers from
     `Adventureland'.  For more ingenious uses of daemon, see the
     helium balloon, the matchbook and (particularly cunning) the pair
     of white gloves in `Toyshop'.

   * Classic timers include the burning match and the hand grenade from
     `Toyshop', the endgame timer from `Advent' and the `Balances'
     cyclops (also employing each_turn).

   * `Adventureland' makes much use of each_turn: see the golden fish,
     the mud, the dragon and the bees.

   * The library extension `timewait.h' by Andrew Clover thoroughly
     implements time of day, allowing the player to "wait until quarter
     past three".

