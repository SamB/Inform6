This is Info file inform.info, produced by Makeinfo-1.64 from the input
file inform.texi.

This is the Inform Designer's Manual, third edition, 4 September 1996,
as updated 16 May 1997.  It was converted to Info by Christopher J.
Madsen <ac608@yfn.ysu.edu>.

Copyright 1996,1997 Graham Nelson and Christopher J. Madsen

Permission is granted to make and distribute copies of this manual
provided that:
 (a) distributed copies are not substantially different from those
     archived by the author,
 (b) this and other copyright messages are always retained in full, and
 (c) no profit is involved.


File: inform,  Node: Properties,  Next: Objects and Routines,  Prev: Attributes,  Up: Appendix

Library properties
==================

The following table lists every library-defined property.  The banner
headings give the name, what type of value makes sense and the default
value (if other than 0).  The symbol (+) means "this property is
additive" so that inherited values from class definitions pile up into
a list, rather than wipe each other out.  Recall that `false' is the
value 0 and `true' the value 1.

n_to, s_to, e_to, w_to, ...                            Room, object or routine
     For rooms:
     These twelve properties (there are also ne_to, nw_to, se_to,
     sw_to, in_to, out_to, u_to and d_to) are the map connections for
     the room.  A value of 0 means "can't go this way".  Otherwise, the
     value should either be a room or a door object: thus, e_to might
     be set to crystal_bridge if the direction "east" means "over the
     crystal bridge".

     Routine returns:
     The room or object the map connects to; or 0 for "can't go this
     way"; or 1 for "can't go this way; stop and print nothing further".

     Warning:
     Do not confuse the direction properties n_to and so on with the
     twelve direction objects, n_obj et al.

add_to_scope                                        List of objects or routine
     For objects:
     When this object is in scope, so are all those listed, or all those
     nominated by the routine.  A routine given here should call
     PlaceInScope(obj) to put obj in scope.

     No return value

after                                                       Routine  NULL  (+)
     Receives actions after they have happened, but before the player
     has been told of them.

     For rooms:
     All actions taking place in this room.

     For objects:
     All actions for which this object is noun (the first object
     specified in the command); and all fake actions for it.

     Routine returns:
     False to continue (and tell the player what has happened), true to
     stop here (printing nothing).

     The Search action is a slightly special case.  Here, after is
     called when it is clear that it would be sensible to look inside
     the object (e.g., it's an open container in a light room) but
     before the contents are described.

article                                                 String or routine  "a"
     For objects:
     Indefinite article for object or routine to print one.

     No return value

articles                                                      Array of strings
     For objects: If given, these are the articles used with the
     object's name.  (Provided for non-English languages where
     irregular nouns may have unusual vowel-contraction rules with
     articles: e.g. with French non-mute `H'.)

before                                                      Routine  NULL  (+)
     Receives advance warning of actions (or fake actions) about to
     happen.

     For rooms:
     All actions taking place in this room.

     For objects:
     All actions for which this object is noun (the first object
     specified in the command); and all fake actions, such as Receive
     and LetGo if this object is the container or supporter concerned.

     Routine returns:
     False to continue with the action, true to stop here (printing
     nothing).

     First special case: A vehicle object receives the Go action if the
     player is trying to drive around in it.  In this case:

     Routine returns:
     0 to disallow as usual; 1 to allow as usual, moving vehicle and
     player; 2 to disallow but do (and print) nothing; 3 to allow but do
     (and print) nothing.  If you want to move the vehicle in your own
     code, return 3, not 2: otherwise the old location may be restored
     by subsequent workings.

     Second special case: in a PushDir action, the before routine must
     call AllowPushDir() and then return true in order to allow the
     attempt (to push an object from one room to another) to succeed.

cant_go                            String or routine  "You can't go that way."
     For rooms:
     Message, or routine to print one, when a player tries to go in an
     impossible direction from this room.

     No return value

capacity                                                Number or routine  100
     For objects:
     Number of objects a container or supporter can hold.

     For the player-object:
     Number of things the player can carry (when the player is this
     object); the default player object (selfobj) has capacity initially
     set to the constant MAX_CARRIED.

daemon                                                           Routine  NULL
     This routine is run each turn, once it has been activated by a
     call to StartDaemon, and until stopped by a call to StopDaemon.

describe                                                    Routine  NULL  (+)
     For objects:
     Called when the object is to be described in a room description,
     before any paragraph break (i.e., skipped line) has been printed.
     A sometimes useful trick is to print nothing in this routine and
     return true, which makes an object `invisible'.

     For rooms:
     Called before a room's long ("look") description is printed.

     Routine returns:
     False to describe in the usual way, true to stop printing here.

description                                                  String or routine
     For objects:
     The Examine message, or a routine to print one out.

     For rooms:
     The long ("look") description, or a routine to print one out.

     No return value

door_dir                                         Direction property or routine
     For compass objects:
     When the player tries to go in this direction, e.g., by typing the
     name of this object, then the map connection tried is the value of
     this direction property for the current room.  For example, the
     n_obj "north" object normally has door_dir set to n_to.

     For objects:
     The direction that this door object goes via (for instance, a
     bridge might run east, in which case this would be set to e_to).

     Routine returns:
     The direction property to try.

door_to                                                        Room or routine
     For objects:
     The place this door object leads to.  A value of 0 means "leads
     nowhere".

     Routine returns:
     The room.  Again, 0 (or false) means "leads nowhere".  Further, 1
     (or true) means "stop the movement action immediately and print
     nothing further".

each_turn                                         String or routine  NULL  (+)
     String to print, or routine to run, at the end of each turn in
     which the object is in scope (after all timers and daemons for
     that turn have been run).

     No return value

found_in                                              List of rooms or routine
     This object will be found in all of the listed rooms, or if the
     routine says so, unless it has the attribute absent.  If an object
     in the list is not a room, it means "present in the same room as
     this object".

     Routine returns:
     True to be present, otherwise false.  The routine can look at the
     current location in order to decide.

     Warning:
     This property is only looked at when the player changes rooms.

grammar                                                                Routine
     For animate or talkable objects:
     This is called when the parser has worked out that the object in
     question is being spoken to, and has decided the verb_word and
     verb_wordnum (the position of the verb word in the word stream)
     but hasn't yet tried any grammar.  The routine can, if it wishes,
     parse past some words (provided it moves verb_wordnum on by the
     number of words it wants to eat up).

     Routine returns:
     False to carry on as usual; true to indicate that the routine has
     parsed the entire command itself, and set up action, noun and
     second to the appropriate order; or a dictionary value for a verb,
     such as 'take', to indicate "parse the command from this verb's
     grammar instead"; or minus such a value, e.g. -'take', to indicate
     "parse from this verb and then parse the usual grammar as well".

initial                                                      String or routine
     For objects:
     The description of an object not yet picked up, used when a room
     is described; or a routine to print one out.

     For rooms:
     Printed or run when the room is arrived in, either by ordinary
     movement or by PlayerTo.

     Warning:
     If the object is a door, or a container, or is switchable, then
     use one of the when_ properties rather than initial.

     No return value

inside_description                                           String or routine
     For objects:
     Printed as part or all of a room description when the player is
     inside the given object, which must be enterable.

invent                                                                 Routine
     This routine is for changing an object's inventory listing.  If
     provided, it's called twice, first with the variable
     inventory_stage set to 1, second with it set to 2.  At stage 1,
     you have an entirely free hand to print a different inventory
     listing.

     Routine returns:
     Stage 1: False to continue; true to stop here, printing nothing
     further about the object or its contents.

     At stage 2, the object's indefinite article and short name have
     already been printed, but messages like " (providing light)"
     haven't.  This is an opportunity to add something like " (almost
     empty)".

     Routine returns:
     Stage 2: False to continue; true to stop here, printing nothing
     further about the object or its contents.

life                                                        Routine  NULL  (+)
     This routine holds rules about animate objects, behaving much like
     before and after but only handling the person-to-person events:

     Attack Kiss WakeOther ThrowAt Give Show Ask Tell Answer Order

     See *Note Living Creatures::, and see also the properties orders
     and grammar.

     Routine returns:
     True to stop and print nothing, false to resume as usual (for
     example, printing "Miss Gatsby has better things to do.").

list_together                                        Number, string or routine
     For objects:
     Objects with the same list_together value are grouped together in
     object lists (such as inventories, or the miscellany at the end of
     a room description).  If a string such as "fish" is given, then
     such a group will be headed with text such as "five fish".

     A routine, if given, is called at two stages in the process (once
     with the variable inventory_stage set to 1, once with it set to 2).
     These stages occur before and after the group is printed; thus, a
     preamble or postscript can be printed.  Also, such a routine may
     change the variable c_style (which holds the current list style).
     On entry, the variable parser_one holds the first object in the
     group, and parser_two the current depth of recursion in the list.
     Applying x=NextEntry(x,parser_two); moves x on from parser_one to
     the next item in the group.  Another helpful variable is
     listing_together, set up to the first object of a group being
     listed (or to 0 whenever no group is being listed).

     Routine returns:
     Stage 1: False to continue, true not to print the group's list at
     all.

     Routine returns:
     Stage 2: No return value.

orders                                                                 Routine
     For animate or talkable objects:
     This carries out the player's orders (or doesn't, as it sees fit):
     it looks at actor, action, noun and second to do so.  Unless this
     object is the current player, actor is irrelevant (it is always
     the player) and the object is the person being ordered about.

     If the player typed an incomprehensible command, like "robot, og
     sthou", then the action is NotUnderstood and the variable etype
     holds the parser's error number.

     If this object is the current player then actor is the person
     being ordered about.  actor can either be this object -- in which
     case an action is being processed, because the player has typed an
     ordinary command -- or can be some other object, in which case the
     player has typed an order.  See *Note Living Creatures:: for how
     to write orders routines in these cases.

     Routine returns:
     True to stop and print nothing further; false to continue.
     (Unless the object is the current player, the life routine's Order
     section gets an opportunity to meddle next; after that, Inform
     gives up.)

name                                             List of dictionary words  (+)
     For objects:
     A list of dictionary words referring to this object.

     Warning:
     The parse_name property of an object may take precedence over this,
     if present.

     For rooms:
     A list of words which the room understands but which refer to
     things which "do not need to be referred to in this game"; these
     are only looked at if all other attempts to understand the
     player's command have failed.

     Warning:
     Uniquely in Inform syntax, these dictionary words are given in
     double quotes "thus", whereas in all other circumstances they
     would be 'thus'.  This means they can safely be only one letter
     long without ambiguity.

number                                                               Any value
     A general purpose property left free: conventionally holding a
     number like "number of turns' battery power left".

     For compass objects:
     Note that the standard compass objects defined by the library all
     provide a number property, in case this might be useful to the
     designer.

     For the player-object:
     Exception: an object to be used as a player-object must provide
     one of these, and musn't use it for anything.

parse_name                                                             Routine
     For objects:
     To parse an object's name (this overrides the name but is also
     used in determining if two objects are describably identical).
     This routine should try to match as many words as possible in
     sequence, reading them one at a time by calling NextWord(). (It
     can leave the "word marker" variable wn anywhere it likes).

     Routine returns:
     0 if the text didn't make any sense at all, -1 to make the parser
     resume its usual course (looking at the name), or the number of
     words in a row which successfully matched.

     In addition to this, if the text matched seems to be in the plural
     (for instance, a blind mouse object reading blind mice), the
     routine can set the variable parser_action to the value
     ##PluralFound.  The parser will then match with all of the
     different objects understood, rather than ask a player which of
     them is meant.

     A parse_name routine may also (voluntarily) assist the parser by
     telling it whether or not two objects which share the same
     parse_name routine are identical.  (They may share the same
     routine if they both inherit it from a class.)  If, when it is
     called, the variable parser_action is set to ##TheSame then this
     is the reason.  It can then decide whether or not the objects
     parser_one and parser_two are indistinguishable.

     Routine returns:
     -1 if the objects are indistinguishable, -2 if not.

plural                                                       String or routine
     For objects:
     The plural name of an object (when in the presence of others like
     it), or routine to print one; for instance, a wax candle might
     have plural set to "wax candles".

     No return value

react_after                                                            Routine
     For objects:
     Acts like an after rule, but detects any actions in the vicinity
     (any actions which take place when this object is in scope).

     Routine returns:
     True to print nothing further; false to carry on.

react_before                                                           Routine
     For objects:
     Acts like a before rule, but detects any actions in the vicinity
     (any actions which take place when this object is in scope).

     Routine returns:
     True to stop the action, printing nothing; false to carry on.

short_name                                                             Routine
     For objects:
     The short name of an object (like "brass lamp"), or a routine to
     print it.

     Routine returns:
     True to stop here, false to carry on by printing the object's
     `real' short name (the string given at the head of the object's
     definition).  It's sometimes useful to print text like "half-empty
     " and then return false.

short_name_indef                                                       Routine
     For objects:
     If set, this form of the short name is used when the name is
     prefaced by an indefinite article.  (This is not useful in
     English-language games, but in other languages adjectival parts of
     names agree with the definiteness of the article.)

time_left                                                               Number
     Number of turns left until the timer for this object (if set,
     which must be done using StartTimer) goes off.  Its initial value
     is of no significance, as StartTimer will write over this, but a
     timer object must provide the property.  If the timer is currently
     set, the value 0 means "will go off at the end of the current
     turn", the value 1 means "...at the end of next turn" and so on.

time_out                                                         Routine  NULL
     Routine to run when the timer for this object goes off (having
     been set by StartTimer and not in the mean time stopped by
     StopTimer).

     Warning:
     A timer object must also provide a time_left property.

when_closed                                                  String or routine
     For objects:
     Description, or routine to print one, of something closed (a door
     or container) in a room's long description.

     No return value

when_open                                                    String or routine
     For objects:
     Description, or routine to print one, of something open (a door or
     container) in a room's long description.

     No return value

when_on                                                      String or routine
     For objects:
     Description, or routine to print one, of a switchable object which
     is currently switched on, in a room's long description.

     No return value

when_off                                                     String or routine
     For objects:
     Description, or routine to print one, of a switchable object which
     is currently switched off, in a room's long description.

     No return value

with_key                                                       Object  nothing
     The key object needed to lock or unlock this lockable object. A
     player must explicitly name it as the key being used and be
     holding it at the time.  The value nothing, or 0, means that no
     key fits (though this is not made clear to the player, who can try
     as many as he likes).


File: inform,  Node: Objects and Routines,  Next: Actions and Fake Actions,  Prev: Properties,  Up: Appendix

Library-defined objects and routines
====================================

   The library defines the following special objects:

`compass'
     To contain the directions.  A direction object provides a door_dir
     property, and should have the direction attribute.  A compass
     direction with enterable, if there is one (which there usually
     isn't), will have an Enter action converted to Go.

`n_obj, ...'
     Both the object signifying the abstract concept of `northness',
     and the `north wall' of the current room.  (Thus, if a player
     types "examine the north wall" then the action Examine n_obj will
     be generated.)  Its door_dir property holds the direction property
     it corresponds to (n_to).  The other such objects are s_obj,
     e_obj, w_obj, ne_obj, nw_obj, se_obj, sw_obj, u_obj, d_obj, in_obj
     and out_obj.  Note that the parser understands "ceiling" to refer
     to u_obj and "floor" to refer to d_obj.  (in_obj and out_obj
     differ slightly, because "in" and "out" are verbs with other
     effects in some cases; these objects should not be removed from
     the compass.)

`thedark'
     A pseudo-room representing `being in darkness'.  location is then
     set to this room, but the player object is not moved to it.  Its
     description can be changed to whatever "It is dark here" message is
     desired.

`selfobj'
     The default player-object.  Code should never refer directly to
     selfobj, but only to player, a variable whose value is usually
     indeed selfobj but which might become green_frog if the player is
     transformed into one.

`InformLibrary'
     Represents the library.  You never need to use it, but it might
     sometimes be the value of sender when a message is received.

`InformParser'
     Represents the parser.

The following routines are defined in the library and available for
public use:

`Achieved(task)'
     Indicate the task is achieved (which only awards score the first
     time).

`AddToScope(obj)'
     Used in an add_to_scope routine of an object to add another object
     into scope whenever the first is in scope.

`AllowPushDir()'
     Signal that an attempt to push an object from one place to another
     should be allowed.

`CDefArt(obj)'
     Print the capitalised definite article and short name of obj.
     Equivalent to print (The) obj;.

`ChangeDefault(p,v)'
     Changes the default value of property p.  (But this won't do
     anything useful to name.)

`ChangePlayer(obj,flag)'
     Cause the player at the keyboard to play as the given object,
     which must have a number property supplied.  If the flag is set to
     1, then subsequently print messages like "(as Ford Prefect)" in
     room description headers.  This routine, however, prints nothing
     itself.

`DefArt(obj)'
     Print the definite article and short name of obj.  Equivalent to
     print (the) obj;.

`DoMenu(text,R1,R2)'
     Produce a menu, using the two routines given.

`EnglishNumber(x)'
     Prints out x in English (e.g., "two hundred and seventy-seven").

`HasLightSource(obj)'
     Returns true if obj `has light'.

`InDefArt(obj)'
     Print the indefinite article and short name of obj.  Equivalent to
     print (a) obj;.

`Locale(obj,tx1,tx2)'
     Prints out the paragraphs of room description which would appear
     if obj were the room: i.e., prints out descriptions of objects in
     obj according to the usual rules.  After describing the objects
     which have their own paragraphs, a list is given of the remaining
     ones.  The string tx1 is printed if there were no previous
     paragraphs, and the string tx2 otherwise.  (For instance, you
     might want "On the ledge you can see" and "On the ledge you can
     also see".)  After the list, nothing else is printed (not even a
     full stop) and the return value is the number of objects in the
     list (possibly zero).

`LoopOverScope(R,actor)'
     Calls routine R(obj) for each object obj in scope.  actor is
     optional: if it's given, then scope is calculated for the given
     actor, not the player.

`NextWord()'
     Returns the next dictionary word in the player's input, moving the
     word number wn on by one.  Returns 0 if the word is not in the
     dictionary or if the word stream has run out.

`NextWordStopped()'
     As NextWord, but returning -1 when the word stream has run out.

`NounDomain(o1,o2,type)'
     This routine is one of the keystones of the parser: the objects
     given are the domains to search through when parsing (almost
     always the location and the actor) and the type indicates a token.
     The only tokens safely usable are: 0: `noun', 1: `held' and 6:
     `creature'.  The routine parses the best single object name it can
     from the current position of wn.  It returns 0 (no match), an
     object number or the constant REPARSE_CODE (to indicate that it
     had to ask a clarifying question: this reconstructed the input
     drastically and the parser must begin all over again).  NounDomain
     should only be used by general parsing routines and these should
     always return REPARSE_CODE if it does.  Note that all of the usual
     scope and name-parsing rules apply to the search performed by
     NounDomain.

`ObjectIsUntouchable(obj,flag)'
     Determines whether any solid barrier (that is, any container that
     is not open) lies between the player and obj.  If flag is set,
     this routine never prints anything; otherwise it prints a message
     like "You can't, because ... is in the way." if any barrier is
     found.  Returns true if a barrier is found, false if not.

`OffersLight(obj)'
     Returns true if obj `offers light'.

`PlaceInScope(obj)'
     Puts obj into scope for the parser.

`PlayerTo(place,flag)'
     Move the player to place.  Unless flag is given and is 1, describe
     the player's surroundings.

`PrintShortName(obj)'
     Print the short name of obj.  (This is protected against obj
     having a meaningless value.) Equivalent to print (name) obj;.

`PronounNotice(obj)'
     Sets all appropriate pronouns to refer to obj.  That is, it works
     out if obj is a thing or a person, of what number and gender, which
     pronouns apply to it in the parser's current language, and so on.

`PronounValue(pronoun)'
     Returns the current setting of pronoun, which may be nothing.  In
     English, pronoun may be 'it', 'him', 'her', or 'them'.

`ScopeWithin(obj)'
     Puts the contents of obj into scope, recursing downward according
     to the usual scope rules.

`SetPronoun(pronoun,obj)'
     Makes pronoun refer to obj, which may be nothing.  In English,
     pronoun may be 'it', 'him', 'her', or 'them'.  You probably want
     to use PronounNotice instead.

`SetTime(time,rate)'
     Set the game clock (a 24-hour clock) to the given time (in seconds
     since the start of the day), to run at the given rate r: r=0 means
     it does not run, if r>0 then r seconds pass every turn, if r<0
     then -r turns pass every second.

`StartDaemon(obj)'
     Makes the daemon of obj active, so that its daemon routine will be
     called every turn.

`StartTimer(obj,time)'
     Starts the timer of obj, set to go off in time turns, at which
     time its time_out routine will be called (it must provide a
     time_left property).

`StopDaemon(obj)'
     Makes the daemon of obj inactive, so that its daemon routine is no
     longer called.

`StopTimer(obj)'
     Stops the timer of obj, so that it won't go off after all.

`TestScope(obj,actor)'
     Returns true if obj is in scope; otherwise false.  actor is
     optional: if it's given, then scope is calculated for the given
     actor, not the player.

`TryNumber(wordnum)'
     Tries to parse the word at wordnum as a number (recognising
     decimal numbers and English ones from "one" to "twenty"),
     returning -1000 if it fails altogether, or the number.  Values
     exceeding 10000 are rounded down to 10000.

`UnsignedCompare(a,b)'
     Returns 1 if a>b, 0 if a=b and a<b, regarding a and b as unsigned
     numbers between 0 and 65535 (or $ffff).  (The usual > condition
     performs a signed comparison.)

`WordAddress(n)'
     Returns the byte array containing the raw text of the n-th word in
     the word stream.

`WordLength(n)'
     Returns the length of the raw text of the n-th word in the word
     stream.

`WriteListFrom(obj,s)'
     Write a list of obj and its siblings, with the style being s (a
     bitmap of options).

`YesOrNo()'
     Assuming that a question has already been printed, wait for the
     player to type "yes" or "no", returning true or false accordingly.

`ZRegion(value)'
     Works out the type of value, if possible.  Returns 1 if it's a
     valid object number, 2 if a routine address, 3 if a string address
     and 0 otherwise.


File: inform,  Node: Actions and Fake Actions,  Next: Library Messages,  Prev: Objects and Routines,  Up: Appendix

Library actions
===============

   The actions implemented by the library are in three groups.  Group 1
consists of actions associated with `meta'-verbs, which are not subject
to game rules.  (If you want a room where the game can't be saved, as
for instance `Spellbreaker' cunningly does, you'll have to tamper with
SaveSub directly, using a Replaced routine.)

1a. Quit, Restart, Restore, Verify, Save, ScriptOn, ScriptOff, Pronouns,
    Score, Fullscore, LMode1, LMode2, LMode3, NotifyOn, NotifyOff,
    Version, Places, Objects.

(Lmode1, Lmode2 and Lmode3 switch between "brief", "verbose" and
"superbrief" room description styles.) In addition, but only if DEBUG
is defined, so that the debugging suite is present, group 1 contains

1b. TraceOn, TraceOff, TraceLevel, ActionsOn, ActionsOff, RoutinesOn,
    RoutinesOff, TimersOn, TimersOff, CommandsOn, CommandsOff, CommandsRead,
    Predictable, XPurloin, XAbstract, XTree, Scope, Goto, Gonear.

Group 2 contains actions which sometimes get as far as the `after'
stage, because the library sometimes does something when processing
them.

2. Inv, InvTall, InvWide, Take, Drop, Remove, PutOn, Insert, Transfer,
   Empty, Enter, Exit, GetOff, Go, GoIn, Look, Examine, Search, Give, Show,
   Unlock, Lock, SwitchOn, SwitchOff, Open, Close, Disrobe, Wear, Eat.

Group 3 contains the remaining actions, which never reach `after'
because the library simply prints a message and stops at the `during'
stage.

3. Yes, No, Burn, Pray, Wake, WakeOther [person], Consult,
   Kiss, Think, Smell, Listen, Taste, Touch, Dig,
   Cut, Jump [jump on the spot], JumpOver, Tie, Drink,
   Fill, Sorry, Strong [swear word], Mild [swear word], Attack, Swim,
   Swing [something], Blow, Rub, Set, SetTo, WaveHands [ie, just "wave"],
   Wave [something], Pull, Push, PushDir [push something in a direction],
   Turn, Squeeze, LookUnder [look underneath something],
   ThrowAt, Answer, Buy, Ask, AskFor, Sing, Climb, Wait, Sleep.

!! The actions PushDir and Go (while the player is inside an enterable
object) have special rules: see *Note Things to Enter::.

The library also defines 8 fake actions:

LetGo, Receive, ThrownAt, Order, TheSame, PluralFound, Miscellany, Prompt

LetGo, Receive and ThrownAt are used to allow the second noun of
Insert, PutOn, ThrowAt, Remove actions to intervene; Order is used to
process actions through somebody's life routine; TheSame and
PluralFound are defined by the parser as ways for the program to
communicate with it; Miscellany and Prompt are defined as slots for
LibraryMessages.


File: inform,  Node: Library Messages,  Next: Entry Points,  Prev: Actions and Fake Actions,  Up: Appendix

Library message numbers
=======================

Answer
    ``There is no reply.''
Ask
    ``There is no reply.''
Attack
    ``Violence isn't the answer to this one.''
Blow
    ``You can't usefully blow that/those.''
Burn
    ``This dangerous act would achieve little.''
Buy
    ``Nothing is on sale.''
Climb
    ``I don't think much is to be achieved by that.''
Close
    1. ``That's/They're not something you can close.''
    2. ``That's/They're already closed.''
    3. ``You close <x1>.''
Consult
    ``You discover nothing of interest in <x1>.''
Cut
    ``Cutting that/those up would achieve little.''
Dig
    ``Digging would achieve nothing here.''
Disrobe
    1. ``You're not wearing that/those.''
    2. ``You take off <x1>.''
Drink
    ``There's nothing suitable to drink here.''
Drop
    1. ``The <x1> is/are already here.''
    2. ``You haven't got that/those.''
    3. ``(first taking <x1> off)''
    4. ``Dropped.''
Eat
    1. ``That's/They're plainly inedible.''
    2. ``You eat <x1>. Not bad.''
EmptyT
    1. <x1> `` can't contain things.''
    2. <x1> `` is/are closed.''
    <x1> `` is/are empty already.''
Enter
    1. ``But you're already on/in <x1>.''
    2. ``That's/They're not something you can enter.''
    3. ``You can't get into the closed <x1>.''
    4. ``You can only get into something freestanding.''
    5. ``You get onto/into <x1>.''
Examine
    1. ``Darkness, noun. An absence of light to see by.''
    2. ``You see nothing special about <x1>.''
    3. ``<x1> is/are currently switched on/off.''
Exit
    1. ``But you aren't in anything at the moment.''
    2. ``You can't get out of the closed <x1>.''
    3. ``You get off/out of <x1>.''
Fill
    ``But there's no water here to carry.''
FullScore
    1. ``The score is/was made up as follows:^''
    2. ``finding sundry items''
    3. ``visiting various places''
    4. ``total (out of MAX_SCORE)''
GetOff
    ``But you aren't on <x1> at the moment.''
Give
    1. ``You aren't holding <x1>.''
    2. ``You juggle <x1> for a while, but don't achieve much.''
    3. ``<x1> doesn't/don't seem interested.''
Go
    1. ``You'll have to get off/out of <x1> first.''
    2. ``You can't go that way.''
    3. ``You are unable to climb <x1>.''
    4. ``You are unable to descend <x1>.''
    5. ``You can't, since <x1> is/are in the way.''
    6. ``You can't, since <x1> leads nowhere.''
Insert
    1. ``You need to be holding <x1> before you
         can put it/them into something else.''
    2. ``That/Those can't contain things.''
    3. ``<x1> is/are closed.''
    4. ``You'll need to take it/them off first.''
    5. ``You can't put something inside itself.''
    6. ``(first taking it/them off)^''
    7. ``There is no more room in <x1>.''
    8. ``Done.''
    9. ``You put <x1> into <second>.''
Inv
    1. ``You are carrying nothing.''
    2. ``You are carrying''
Jump
    ``You jump on the spot, fruitlessly.''
JumpOver
    ``You would achieve nothing by this.''
Kiss
    ``Keep your mind on the game.''
Listen
    ``You hear nothing unexpected.''
LMode1
    `` is now in its normal ~brief~ printing mode, which gives
       long descriptions of places never before visited and short
       descriptions otherwise.''
LMode2
    `` is now in its ~verbose~ mode, which always gives long
       descriptions of locations (even if you've been there before).''
LMode3
    `` is now in its ~superbrief~ mode, which always gives short
       descriptions of locations (even if you haven't been there before).''
Lock
    1. ``That doesn't/They don't seem to be something you can lock.''
    2. ``That's/They're locked at the moment.''
    3. ``First you'll have to close <x1>.''
    4. ``That doesn't/Those don't seem to fit the lock.''
    5. ``You lock <x1>.''
Look
    1. `` (on <x1>)''
    2. `` (in <x1>)''
    3. `` (as <x1>)''
    4. ``^On <x1> is/are <list>''
    5. ``[On/In <x1>] you/You can also see <list> [here].''
    6. ``[On/In <x1>] you/You can see <list> [here].''
LookUnder
    1. ``But it's dark.''
    ``You find nothing of interest.''
Mild
    ``Quite.''
ListMiscellany
    1. `` (providing light)''
    2. `` (which is/are closed)''
    3. `` (closed and providing light)''
    4. `` (which is/are empty)''
    5. `` (empty and providing light)''
    6. `` (which is/are closed and empty)''
    7. `` (closed, empty and providing light)''
    8. `` (providing light and being worn''
    9. `` (providing light''
   10. `` (being worn''
   11. `` (which is/are ''
   12. ``open''
   13. ``open but empty''
   14. ``closed''
   15. ``closed and locked''
   16. `` and empty''
   17. `` (which is/are empty)''
   18. `` containing ''
   19. `` (on ''
   20. ``, on top of ''
   21. `` (in ''
   22. ``, inside ''
Miscellany
    1. ``(considering the first sixteen objects only)^''
    2. ``Nothing to do!''
    3. `` You have died ''
    4. `` You have won ''
    5. (The RESTART/RESTORE/QUIT and possibly FULL
        and AMUSING query, printed after the game is over.)
    6. ``[Your interpreter does not provide undo. Sorry!]''
    7. ``Undo failed. [Not all interpreters provide it.]''
    8. ``Please give one of the answers above.''
    9. ``^It is now pitch dark in here!''
   10. ``I beg your pardon?''
   11. ``[You can't ``undo'' what hasn't been done!]''
   12. ``[Can't ``undo'' twice in succession. Sorry!]''
   13. ``[Previous turn undone.]''
   14. ``Sorry, that can't be corrected.''
   15. ``Think nothing of it.''
   16. ````Oops'' can only correct a single word.''
   17. ``It is pitch dark, and you can't see a thing.''
   18. ``yourself'' (the short name of the selfobj object)
   19. ``As good-looking as ever.''
   20. ``To repeat a command like ``frog, jump'', just say
         ``again'', not ``frog, again''.''
   21. ``You can hardly repeat that.''
   22. ``You can't begin with a comma.''
   23. ``You seem to want to talk to someone, but I can't see whom.''
   24. ``You can't talk to <x1>.''
   25. ``To talk to someone, try ``someone, hello'' or some such.''
   26. ``(first taking not_holding)''
   27. ``I didn't understand that sentence.''
   28. ``I only understood you as far as wanting to ''
   29. ``I didn't understand that number.''
   30. ``You can't see any such thing.''
   31. ``You seem to have said too little!''
   32. ``You aren't holding that!''
   33. ``You can't use multiple objects with that verb.''
   34. ``You can only use multiple objects once on a line.''
   35. ``I'm not sure what ``<pronoun>'' refers to.''
   36. ``You excepted something not included anyway!''
   37. ``You can only do that to something animate.''
   38. ``That's not a verb I recognise.''
   39. ``That's not something you need to refer to in the
         course of this game.''
   40. ``You can't see ``<pronoun>'' (<value>) at the moment.''
   41. ``I didn't understand the way that finished.''
   42. ``None/only <x1> of those is/are available.''
   43. ``Nothing to do!''
   44. ``There are none at all available!''
   45. ``Who do you mean, ''
   46. ``Which do you mean, ''
   47. ``Sorry, you can only have one item here. Which exactly?''
   48. ``Whom do you want [<actor>] to <command>?''
   49. ``What do you want [<actor>] to <command>?''
   50. ``Your score has just gone up/down by <x1> point/points.''
   51. ``(Since something dramatic has happened, your list of
         commands has been cut short.)''
   52. ``Type a number from 1 to <x1>, 0 to redisplay or press ENTER.''
   53. ``[Please press SPACE.]''
No
    see `Yes'
NotifyOff
    ``Score notification off.''
NotifyOn
    ``Score notification on.''
Objects
    1. ``Objects you have handled:^''
    2. ``None.''
    3. ``   (worn)''
    4. ``   (held)''
    5. ``   (given away)''
    6. ``   (in <x1>)'' [without article]
    7. ``   (in <x1>)'' [with article]
    8. ``   (inside <x1>)''
    9. ``   (on <x1>)''
   10. ``   (lost)''
Open
    1. ``That's/They're not something you can open.''
    2. ``It seems/They seem to be locked.''
    3. ``That's/They're already open.''
    4. ``You open <x1>, revealing <children>''
    5. ``You open <x1>.''
Order
    ``<x1> has/have better things to do.''
Places
    ``You have visited: ''
Pray
    ``Nothing practical results from your prayer.''
Prompt
    1. ``^>''
Pronouns
    1. ``At the moment, ''
    2. ``means ''
    3. ``is unset ''
    4. ``no pronouns are known to the game.''
Pull
    1. ``It is/Those are fixed in place.''
    2. ``You are unable to.''
    3. ``Nothing obvious happens.''
    4. ``That would be less than courteous.''
Push
    see `Pull'
PushDir
    1. ``Is that the best you can think of?''
    2. ``That's not a direction.''
    3. ``Not that way you can't.''
PutOn
    1. ``You need to be holding <x1> before you
         can put it/them on top of something else.''
    2. ``You can't put something on top of itself.''
    3. ``Putting things on <x1> would achieve nothing.''
    4. ``You lack the dexterity.''
    5. ``(first taking it/them off)^''
    6. ``There is no more room on <x1>.''
    7. ``Done.''
    8. ``You put <x1> on <second>.''
Quit
    1. ``Please answer yes or no.''
    2. ``Are you sure you want to quit? ''
Remove
    1. ``It is/They are unfortunately closed.''
    2. ``But it isn't/they aren't there now.''
    3. ``Removed.''
Restart
    1. ``Are you sure you want to restart? ''
    2. ``Failed.''
Restore
    1. ``Restore failed.''
    2. ``Ok.''
Rub
    ``You achieve nothing by this.''
Save
    1. ``Save failed.''
    2. ``Ok.''
Score
    ``You have so far/In that game you scored <score> out of
      a possible MAX_SCORE, in <turns> turn/turns''
ScriptOn
    1. ``Transcripting is already on.''
    2. ``Start of a transcript of''
ScriptOff
    1. ``Transcripting is already off.''
    2. ``^End of transcript.''
Search
    1. ``But it's dark.''
    2. ``There is nothing on <x1>.''
    3. ``On <x1> is/are <list of children>.''
    4. ``You find nothing of interest.''
    5. ``You can't see inside, since <x1> is/are closed.''
    6. ``<x1> is/are empty.''
    7. ``In <x1> is/are <list of children>.''
Set
    ``No, you can't set that/those.''
SetTo
    ``No, you can't set that/those to anything.''
Show
    1. ``You aren't holding <x1>.''
    2. ``<x1> is/are unimpressed.''
Sing
    ``Your singing is abominable.''
Sleep
    ``You aren't feeling especially drowsy.''
Smell
    ``You smell nothing unexpected.''
Sorry
    ``Oh, don't apologise.''
Squeeze
    1. ``Keep your hands to yourself.''
    2. ``You achieve nothing by this.''
Strong
    ``Real adventurers do not use such language.''
Swim
    ``There's not enough water to swim in.''
Swing
    ``There's nothing sensible to swing here.''
SwitchOff
    1. ``That's/They're not something you can switch.''
    2. ``That's/They're already off.''
    3. ``You switch <x1> off.''
SwitchOn
    1. ``That's/They're not something you can switch.''
    2. ``That's/They're already on.''
    3. ``You switch <x1> on.''
Take
    1. ``Taken.''
    2. ``You are always self-possessed.''
    3. ``I don't suppose <x1> would care for that.''
    4. ``You'd have to get off/out of <x1> first.''
    5. ``You already have that/those.''
    6. ``That seems/Those seem to belong to <x1>.''
    7. ``That seems/Those seem to be a part of <x1>.''
    8. ``That isn't/Those aren't available.''
    9. ``<x1> isn't/aren't open.''
   10. ``That's/They're hardly portable.''
   11. ``That's/They're fixed in place.''
   12. ``You're carrying too many things already.''
   13. ``(putting <x1> into SACK_OBJECT to make room)''
Taste
    ``You taste nothing unexpected.''
Tell
    1. ``You talk to yourself a while.''
    2. ``This provokes no reaction.''
Touch
    1. ``Keep your hands to yourself!''
    2. ``You feel nothing unexpected.''
    3. ``If you think that'll help.''
Think
    ``What a good idea.''
Tie
    ``You would achieve nothing by this.''
ThrowAt
    1. ``Futile.''
    2. ``You lack the nerve when it comes to the crucial moment.''
Turn
    see `Pull'
Unlock
    1. ``That doesn't seem to be something you can unlock.''
    2. ``It's/They're unlocked at the moment.''
    3. ``That doesn't/Those don't seem to fit the lock.''
    4. ``You unlock <x1>.''
VagueGo
    ``You'll have to say which compass direction to go in.''
Verify
    1. ``The game file has verified as intact.''
    2. ``The game file did not verify properly, and may be corrupted
         (or you may be running it on a very primitive interpreter which
         is unable properly to perform the test).''
Wait
    ``Time passes.''
Wake
    ``The dreadful truth is, this is not a dream.''
WakeOther
    ``That seems unnecessary.''
Wave
    1. ``But you aren't holding that/those.''
    2. ``You look ridiculous waving <x1>.''
WaveHands
    ``You wave, feeling foolish.''
Wear
    1. ``You can't wear that/those!''
    2. ``You're not holding that/those!''
    3. ``You're already wearing that/those!''
    4. ``You put on <x1>.''
Yes
    ``That was a rhetorical question.''

