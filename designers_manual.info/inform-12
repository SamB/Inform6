This is Info file inform.info, produced by Makeinfo-1.64 from the input
file inform.texi.

This is the Inform Designer's Manual, third edition, 4 September 1996.
It was converted to Info by Christopher J. Madsen <ac608@yfn.ysu.edu>.

Copyright 1996 Graham Nelson and Christopher J. Madsen

Permission is granted to make and distribute copies of this manual
provided that:
 (a) distributed copies are not substantially different from those
     archived by the author,
 (b) this and other copyright messages are always retained in full, and
 (c) no profit is involved.


File: inform,  Node: Answer 8,  Next: Answer 9,  Prev: Answer 7,  Up: Answers

Answer to Exercise 8: exchanging "east"/"west"
==============================================

   This is a prime candidate for using variable strings @nn.  Briefly:
at the head of the source, define

Lowstring east_str "east"; Lowstring west_str "west";

and then add two more routines to the game,

[ NormalWorld; String 0 east_str; String 1 west_str; ];
[ ReversedWorld; String 0 west_str; String 1 east_str; ];

where NormalWorld is called in Initialise or to go back to normal, and
ReversedWorld when the reflection happens.  Write @00 in place of east
in any double-quoted printable string, and similarly @01 for west.  It
will be printed as whichever is currently set.  (Inform provides up to
32 such variable strings.)

   *Note Exercise 8: Places.


File: inform,  Node: Answer 9,  Next: Answer 10,  Prev: Answer 8,  Up: Answers

Answer to Exercise 9: acquisitive bag
=====================================

Object -> bag "toothed bag"
  with name "toothed" "bag",
       description "A capacious bag with a toothed mouth.",
       before
       [; LetGo: "The bag defiantly bites itself
                  shut on your hand until you desist.";
          Close: "The bag resists all attempts to close it.";
       ],
       after
       [; Receive:
                 print_ret "The bag wriggles hideously as it swallows ",
                           (the) noun, ".";
       ],
  has  container open;

   *Note Exercise 9: Containers.


File: inform,  Node: Answer 10,  Next: Answer 11,  Prev: Answer 9,  Up: Answers

Answer to Exercise 10: television set
=====================================

Object television "portable television set" lounge
  with name "tv" "television" "set" "portable",
       before
       [;  SwitchOn: <<SwitchOn power_button>>;
           SwitchOff: <<SwitchOff power_button>>;
           Examine: <<Examine screen>>;
       ],
  has  transparent;
Object -> power_button "power button"
  with name "power" "button" "switch",
       after
       [;  SwitchOn, SwitchOff: <<Examine screen>>;
       ],
  has  switchable;
Object -> screen "television screen"
  with name "screen",
       before
       [;  Examine: if (power_button hasnt on) "The screen is black.";
               "The screen writhes with a strange Japanese cartoon.";
       ];

   *Note Exercise 10: Containers.


File: inform,  Node: Answer 11,  Next: Answer 12,  Prev: Answer 10,  Up: Answers

Answer to Exercise 11: glass and steel boxes
============================================

Object -> glass_box "glass box with a lid"
  with name "glass" "box" "with" "lid"
  has  container transparent openable open;
Object -> steel_box "steel box with a lid"
  with name "steel" "box" "with" "lid"
  has  container openable open;

   *Note Exercise 11: Containers.


File: inform,  Node: Answer 12,  Next: Answer 13,  Prev: Answer 11,  Up: Answers

Answer to Exercise 12: macrame bag
==================================

   (The describe part of this answer but is only decoration.)  Note the
careful use of inp1 and inp2 rather than noun or second: see the note
at the end of *Note Actions and Reactions::.

Object -> macrame_bag "macrame bag"
  with name "macrame" "bag" "string" "net" "sack",
       react_before
       [;  Examine, Search, Listen, Smell: ;
           default:
               if (inp1>1 && inp1 in self)
                   print_ret (The) inp1, " is tucked away in the bag.";
               if (inp2>1 && inp2 in self)
                   print_ret (The) inp2, " is tucked away in the bag.";
       ],
       describe
       [;  print "^A macrame bag hangs from the ceiling, shut tight";
           if (child(self)==0) ".";
           print ".  Inside you can make out ";
           WriteListFrom(child(self), ENGLISH_BIT); ".";
       ],
  has  container transparent;
Object watch "gold watch" macrame_bag
  with name "gold" "watch",
       description "The watch has no hands, oddly.",
       react_before
       [;  Listen: if (noun==0 or self) "The watch ticks loudly."; ];

   *Note Exercise 12: Containers.


File: inform,  Node: Answer 13,  Next: Answer 14,  Prev: Answer 12,  Up: Answers

Answer to Exercise 13: plank bridge
===================================

   The "plank breaking" rule is implemented here in its door_to routine.
Note that this returns `true' after killing the player.

Object -> PlankBridge "plank bridge"
  with description "Extremely fragile and precarious.",
       name "precarious" "fragile" "wooden" "plank" "bridge",
       when_open
           "A precarious plank bridge spans the chasm.",
       door_to
       [;  if (children(player)~=0)
           {   deadflag=1;
              "You step gingerly across the plank, which bows under
               your weight. But your meagre possessions are the straw
               which breaks the camel's back! There is a horrid crack...";
           }
           print "You step gingerly across the plank, grateful that
                  you're not burdened.^";
           if (location==NearSide) return FarSide; return NearSide;
       ],
       door_dir
       [;  if (location==NearSide) return s_to; return n_to;
       ],
       found_in NearSide FarSide,
  has  static door open;

There might be a problem with this solution if your game also contained
a character who wandered about, and whose code was clever enough to run
door_to routines for any doors it ran into.  If so, door_to could
perhaps be modified to check that the actor is the player.

   *Note Exercise 13: Doors.


File: inform,  Node: Answer 14,  Next: Answer 15,  Prev: Answer 13,  Up: Answers

Answer to Exercise 14: cage to open and enter
=============================================

Object -> cage "iron cage"
  with name "iron" "cage" "bars" "barred" "iron-barred",
       when_open
          "An iron-barred cage, large enough to stoop over inside,
           looms ominously here.",
       when_closed "The iron cage is closed.",
  has  enterable container openable open static;

   *Note Exercise 14: Things to Enter.


File: inform,  Node: Answer 15,  Next: Answer 16,  Prev: Answer 14,  Up: Answers

Answer to Exercise 15: car that won't go east
=============================================

   Change the car's before to

    before
    [; Go: if (noun==e_obj)
           {   print "The car will never fit through your front door.^";
               return 2;
           }
           if (car has on) "Brmm!  Brmm!";
           print "(The ignition is off at the moment.)^";
    ],

   *Note Exercise 15: Things to Enter.


File: inform,  Node: Answer 16,  Next: Answer 17,  Prev: Answer 15,  Up: Answers

Answer to Exercise 16: pushing pumice ball uphill
=================================================

   Insert these lines into the before rule for PushDir:

               if (second==u_obj) <<PushDir self n_obj>>;
               if (second==d_obj) <<PushDir self s_obj>>;

   *Note Exercise 16: Things to Enter.


File: inform,  Node: Answer 17,  Next: Answer 18,  Prev: Answer 16,  Up: Answers

Answer to Exercise 17: Tyndale's Bible
======================================

Object -> bible "black Tyndale Bible"
  with name "bible" "black" "book",
       initial "A black Bible rests on a spread-eagle lectern.",
       description "A splendid foot-high Bible, which must have survived
           the burnings of 1520.",
       before
       [ w x; Consult:
               wn = consult_from; w = NextWord();
               switch(w)
               {   'matthew': x="Gospel of St Matthew";
                   'mark': x="Gospel of St Mark";
                   'luke': x="Gospel of St Luke";
                   'john': x="Gospel of St John";
                   default: "There are only the four Gospels.";
               }
               if (consult_words==1)
                   print_ret "You read the ", (string) x, " right through.";
               w = TryNumber(wn);
               if (w==-1000)
                   print_ret "I was expecting a chapter number in the ",
                             (string) x, ".";
               print_ret "Chapter ", (number) w, " of the ", (string) x,
                     " is too sacred for you to understand now.";
       ];

   *Note Exercise 17: Reading Matter.


File: inform,  Node: Answer 18,  Next: Answer 19,  Prev: Answer 17,  Up: Answers

Answer to Exercise 18: bearded psychiatrist
===========================================

   Note that whether reacting before or after, the psychiatrist does
not cut any actions short, because react_before and react_after both
return false.

Object -> psychiatrist "bearded psychiatrist"
  with name "bearded" "doctor" "psychiatrist" "psychologist" "shrink",
       initial "A bearded psychiatrist has you under observation.",
       life
       [;  "He is fascinated by your behaviour, but makes no attempt to
            interfere with it.";
       ],
       react_after
       [;  Insert: print "~Subject puts ", (name) noun, " in ",
                       (name) second, ". Interesting.~^^";
           Look: print "~Pretend I'm not here,~ says the psychiatrist.^";
       ],
       react_before
       [;  Take, Remove: print "~Subject feels lack of ", (the) noun,
               ". Suppressed Oedipal complex? Mmm.~^";
       ],
  has  animate;

   *Note Exercise 18: Living Creatures.


File: inform,  Node: Answer 19,  Next: Answer 20,  Prev: Answer 18,  Up: Answers

Answer to Exercise 19: removing conversation actions
====================================================

   Add the following lines, after the inclusion of Grammar:

[ SayInsteadSub; "[To talk to someone, please type ~someone, something~
or else ~ask someone about something~.]"; ];
Extend "answer" replace * ConTopic -> SayInstead;
Extend "tell"   replace * ConTopic -> SayInstead;

A slight snag is that this will throw out "nigel, tell me about the
grunfeld defence" (which the library will normally convert to an Ask
action, but can't if the grammar for "tell" is missing); to avoid this,
you could instead Replace the TellSub routine (*note Extending the
Library::.) by the SayInsteadSub one.

   *Note Exercise 19: Living Creatures.


File: inform,  Node: Answer 20,  Next: Answer 21,  Prev: Answer 19,  Up: Answers

Answer to Exercise 20: computer (voice-activated)
=================================================

   There are several ways to do this.  The easiest is to add more
grammar to the parser and let it do the hard work:

Object -> computer "computer"
  with name "computer",
       orders
       [;  Theta: print_ret "~Theta now set to ", noun, ".~";
           default: print_ret "~Please rephrase.~";
       ],
  has  talkable;
...
[ ThetaSub; "You must tell your computer so."; ];
Verb "theta" * "is" number -> Theta;

   *Note Exercise 20: Living Creatures.


File: inform,  Node: Answer 21,  Next: Answer 22,  Prev: Answer 20,  Up: Answers

Answer to Exercise 21: Charlotte playing Simon Says
===================================================

   Obviously, a slightly wider repertoire of actions might be a good
idea, but:

Object -> Charlotte "Charlotte"
  with name "charlotte" "charlie" "chas",
       grammar
       [;  give self ~general;
           wn=verb_wordnum;
           if (NextWord()=='simon' && NextWord()=='says')
           {   give self general;
               verb_wordnum=verb_wordnum+2;
           }
       ],
       orders
       [ i;  if (self hasnt general) "Charlotte sticks her tongue out.";
           WaveHands: "Charlotte waves energetically.";
           default: "~Don't know how,~ says Charlotte.";
       ],
       initial "Charlotte wants to play Simon Says.",
  has  animate female proper;

   *Note Exercise 21: Living Creatures.


File: inform,  Node: Answer 22,  Next: Answer 23,  Prev: Answer 21,  Up: Answers

Answer to Exercise 22: Charlotte's clapping game
================================================

   First add a Clap verb (this is easy).  Then give Charlotte a number
property (initially 0, say) and add these three lines to the end of
Charlotte's grammar routine:

           self.number=TryNumber(verb_wordnum);
           if (self.number~=-1000)
           {    action=##Clap; noun=0; second=0; rtrue; }

Her orders routine now needs a local variable called i, and the new
clause:

           Clap: if (self.number==0) "Charlotte folds her arms.";
                 for (i=0:i<self.number:i++)
                 {   print "Clap! ";
                     if (i==100)
                         print "(You must be regretting this by now.) ";
                     if (i==200)
                         print "(What a determined girl she is.) ";
                 }
                 if (self.number>100)
                    "^^Charlotte is a bit out of breath now.";
                "^^~Easy!~ says Charlotte.";

   *Note Exercise 22: Living Creatures.


File: inform,  Node: Answer 23,  Next: Answer 24,  Prev: Answer 22,  Up: Answers

Answer to Exercise 23: Dyslexic Dan
===================================

   The interesting point here is that when the grammar property finds
the word "take", it accepts it and has to move verb_wordnum on by one
to signal that a word has been parsed succesfully.

Object -> Dan "Dyslexic Dan"
  with name "dan" "dyslexic",
       grammar
       [;  if (verb_word == 'take') { verb_wordnum++; return 'drop'; }
           if (verb_word == 'drop') { verb_wordnum++; return 'take'; }
       ],
       orders
       [ i;
           Take: print_ret "~What,~ says Dan, ~ you want me to take ",
                     (the) noun, "?~";
           Drop: print_ret "~What,~ says Dan, ~ you want me to drop ",
                     (the) noun, "?~";
           Inv: "~That I can do,~ says Dan. ~I'm empty-handed.~";
           No: "~Right you be then.~";
           Yes: "~I'll be having to think about that.~";
           default: "~Don't know how,~ says Dan.";
       ],
       initial "Dyslexic Dan is here.",
  has  animate proper;

   *Note Exercise 23: Living Creatures.


File: inform,  Node: Answer 24,  Next: Answer 25,  Prev: Answer 23,  Up: Answers

Answer to Exercise 24: extensions for one actor only
====================================================

   Suppose Dan's grammar (but nobody else's) for the "examine" verb is
to be extended.  His grammar routine should also contain:

           if (verb_word == 'examine' or 'x')
           {   verb_wordnum++; return -'danx,'; }

(Note the crudity of this: it looks at the actual verb word, so you
have to check any synonyms yourself.)  The verb "danx," must be
declared later:

Verb "danx," * "conscience" -> Inv;

and now "Dan, examine conscience" will send him an Inv order: but "Dan,
examine cow pie" will still send Examine cow_pie as usual.

   *Note Exercise 24: Living Creatures.


File: inform,  Node: Answer 25,  Next: Answer 26,  Prev: Answer 24,  Up: Answers

Answer to Exercise 25: alarm clock
==================================

[ PrintTime x; print (x/60), ":", (x%60)/10, (x%60)%10; ];
Object -> alarm_clock "alarm clock"
  with name "alarm" "clock",
       number 480,
       description
       [;  print "The alarm is ";
           if (self has general) print "on, "; else print "off, but ";
           print_ret "the clock reads ", (PrintTime) the_time,
                 " and the alarm is set for ", (PrintTime) self.number, ".";
       ],
       react_after
       [;  Inv:  if (self in player)   { new_line; <<Examine self>>; }
           Look: if (self in location) { new_line; <<Examine self>>; }
       ],
       daemon
       [;  if (the_time >= self.number && the_time <= self.number+3
               && self has general) "^Beep! Beep! The alarm goes off.";
       ],
       grammar [; return 'alarm,'; ],
       orders
       [;  SwitchOn:  give self general; StartDaemon(self); "~Alarm set.~";
           SwitchOff: give self ~general; StopDaemon(self); "~Alarm off.~";
           SetTo:     self.number=noun; <<Examine self>>;
           default: "~Commands are on, off or a time of day only, pliz.~";
       ],
       life
       [;  Ask, Answer, Tell:
              "[Try ~clock, something~ to address the clock.]";
       ],
  has  talkable;

and add a new verb to the grammar:

Verb "alarm," * "on"      -> SwitchOn
              * "off"     -> SwitchOff
              * TimeOfDay -> SetTo;

(using the `TimeOfDay' token from the exercises of *note Grammar
Tokens::.).  Note that since the word "alarm," can't be matched by
anything the player types, this verb is concealed from ordinary
grammar.  The orders we produce here are not used in the ordinary way
(for instance, the action SwitchOn with no noun or second would never
ordinarily be produced by the parser) but this doesn't matter: it only
matters that the grammar and the orders property agree with each other.

   *Note Exercise 25: Living Creatures.


File: inform,  Node: Answer 26,  Next: Answer 27,  Prev: Answer 25,  Up: Answers

Answer to Exercise 26: tricorder
================================

Object -> tricorder "tricorder"
  with name "tricorder",
       grammar [; return 'tc,'; ],
       orders
       [;  Examine: if (noun==player) "~You radiate life signs.~";
               print "~", (The) noun, " radiates ";
               if (noun hasnt animate) print "no ";
              "life signs.~";
           default: "The tricorder bleeps.";
       ],
       life
       [;  Ask, Answer, Tell: "The tricorder is too simple.";
       ],
  has  talkable;
...
Verb "tc,"    * noun      -> Examine;

   *Note Exercise 26: Living Creatures.


File: inform,  Node: Answer 27,  Next: Answer 28,  Prev: Answer 26,  Up: Answers

Answer to Exercise 27: replicator
=================================

Object replicator "replicator"
  with name "replicator",
       grammar [;  return 'rc,'; ],
       orders
       [;  Give:
               print_ret "The replicator serves up a cup of ",
                   (name) noun, " which you drink eagerly.";
           default: "The replicator is unable to oblige.";
       ],
       life
       [;  Ask, Answer, Tell: "The replicator has no conversation skill.";
       ],
  has  talkable;
Object -> earl_grey "Earl Grey tea"    with name "earl" "grey" "tea";
Object -> brandy    "Aldebaran brandy" with name "aldebaran" "brandy";
Object -> water     "distilled water"  with name "distilled" "water";
...
Verb "rc,"    * held      -> Give;

The point to note here is that the `held' token means `held by the
replicator' here, as the actor is the replicator, so this is a neat way
of getting a `one of the following phrases' token into the grammar.

   *Note Exercise 27: Living Creatures.


File: inform,  Node: Answer 28,  Next: Answer 29,  Prev: Answer 27,  Up: Answers

Answer to Exercise 28: communications badge
===========================================

   This is similar to the previous exercises.  One creates an attribute
called crewmember and gives it to the crew objects: the orders property
is

       orders
       [;  Examine:
               if (parent(noun)==0)
                   print_ret "~", (name) noun,
                       " is no longer aboard this demonstration game.~";
               print_ret "~", (name) noun, " is in ", (name) parent(noun), ".~";
           default: "The computer's only really good for locating the crew.";
       ],

and the grammar simply returns 'stc,' which is defined as

[ Crew i;
  switch(scope_stage)
  {  1: rfalse;
     2: for (i=selfobj+1:i<=top_object:i++)
            if (i has crewmember) PlaceInScope(i); rtrue;
  }
];
Verb "stc,"   * "where" "is" scope=Crew -> Examine;

An interesting point is that the scope routine doesn't need to do
anything at stage 3 (usually used for printing out errors) because the
normal error-message printing system is never reached.  Something like
"computer, where is Comminder Doto" causes a ##NotUnderstood order.

   *Note Exercise 28: Living Creatures.


File: inform,  Node: Answer 29,  Next: Answer 30,  Prev: Answer 28,  Up: Answers

Answer to Exercise 29: Zen flight computer
==========================================

Object Zen "Zen" Flight_Deck
  with name "zen" "flight" "computer",
       initial "Square lights flicker unpredictably across a hexagonal
                fascia on one wall, indicating that Zen is on-line.",
       grammar [;  return 'zen,'; ],
       orders
       [;  Show: print_ret "The main screen shows a starfield,
                     turning through ", noun, " degrees.";
           Go:  "~Confirmed.~  The ship turns to a new bearing.";
           SetTo: if (noun==0) "~Confirmed.~  The ship comes to a stop.";
               if (noun>12) print_ret "~Standard by ", (number) noun,
                                " exceeds design tolerances.~";
               print_ret "~Confirmed.~  The ship's engines step to
                   standard by ", (number) noun, ".";
           Take: if (noun~=force_wall) "~Please clarify.~";
                "~Force wall raised.~";
           Drop: if (noun~=blasters)   "~Please clarify.~";
              "~Battle-computers on line.
                Neutron blasters cleared for firing.~";
           default: "~Language banks unable to decode.~";
       ],
  has  talkable proper static;
Object -> force_wall "force wall"     with name "force" "wall" "shields";
Object -> blasters "neutron blasters" with name "neutron" "blasters";
...
Verb "zen,"   * "scan" number "orbital"        -> Show
              * "set" "course" "for" Planet    -> Go
              * "speed" "standard" "by" number -> SetTo
              * "raise" held                   -> Take
              * "clear" held "for" "firing"    -> Drop;

Dealing with Ask, Answer and Tell are left to the reader.

   *Note Exercise 29: Living Creatures.


File: inform,  Node: Answer 30,  Next: Answer 31,  Prev: Answer 29,  Up: Answers

Answer to Exercise 30: Picard and Maharg
========================================

[ InScope;
   if (action_to_be == ##Examine or ##Show or ##ShowR)
       PlaceInScope(noslen_maharg);
   if (scope_reason == TALKING_REASON)
       PlaceInScope(noslen_maharg);
];

Note that ShowR is a variant form of Show in which the parameters are
`the other way round': thus "show maharg the phaser" generates ShowR
maharg phaser internally, which is then converted to the more usual
Show phaser maharg.

   *Note Exercise 30: Living Creatures.


File: inform,  Node: Answer 31,  Next: Answer 32,  Prev: Answer 30,  Up: Answers

Answer to Exercise 31: Martha the telepath
==========================================

   Martha and the sealed room are defined as follows:

Object sealed_room "Sealed Room"
  with description
          "I'm in a sealed room, like a squash court without a door,
           maybe six or seven yards across",
  has  light;
Object -> ball "red ball" with name "red" "ball";
Object -> martha "Martha"
  with name "martha",
       orders
       [ r; r=parent(self);
           Give:
               if (noun notin r) "~That's beyond my telekinesis.~";
               if (noun==self) "~Teleportation's too hard for me.~";
               move noun to player;
               print_ret "~Here goes...~ and Martha's telekinetic talents
                   magically bring ", (the) noun, " to your hands.";
           Look:
               print "~", (string) r.description;
               if (children(r)==1) ".  There's nothing here but me.~";
               print ".  I can see ";
               WriteListFrom(child(r),CONCEAL_BIT+ENGLISH_BIT);
              ".~";
           default: "~Afraid I can't help you there.~";
       ],
       life
       [;  Ask: "~You're on your own this time.~";
           Tell: "Martha clucks sympathetically.";
           Answer: "~I'll be darned,~ Martha replies.";
       ],
   has animate female concealed proper;

but the really interesting part is the InScope routine to fix things up:

[ InScope actor;
   if (actor==martha) PlaceInScope(player);
   if (actor==player && scope_reason==TALKING_REASON)
       PlaceInScope(martha);
   rfalse;
];

Note that since we want two-way communication, the player has to be in
scope to Martha too: otherwise Martha won't be able to follow the
command "martha, give me the fish", because "me" will refer to
something beyond her scope.

   *Note Exercise 31: Living Creatures.


File: inform,  Node: Answer 32,  Next: Answer 33,  Prev: Answer 31,  Up: Answers

Answer to Exercise 32: troll afraid of the dark
===============================================

   Just test if HasLightSource(gift)==1.

   *Note Exercise 32: Light and Dark.


File: inform,  Node: Answer 33,  Next: Answer 34,  Prev: Answer 32,  Up: Answers

Answer to Exercise 33: pet moth escapes in the dark
===================================================

   We could solve this using a daemon, but for the sake of
demonstrating a feature of thedark we won't.  In Initialise, write
thedark.initial = #r$GoMothGo; and add the routine:

[ GoMothGo;
   if (moth in player)
   {   remove moth;
      "As your eyes try to adjust, you feel a ticklish sensation
       and hear a tiny fluttering sound.";
   }
];

   *Note Exercise 33: Light and Dark.


File: inform,  Node: Answer 34,  Next: Answer 35,  Prev: Answer 33,  Up: Answers

Answer to Exercise 34: thief who wanders
========================================

   This is a crude implementation, for brevity (the real Zork thief has
an enormous stock of attached messages).  A life routine is omitted,
and of course this particular thief steals nothing.  See `The Thief'
for a much fuller, annotated implementation.

Object -> thief "thief"
  with name "thief" "gentleman" "mahu" "modo",
       each_turn "^The thief growls menacingly.",
       daemon
       [ i p j n k;
           if (random(3)~=1) rfalse;
           p=parent(thief);
           objectloop (i in compass)
           {   j=p.(i.door_dir);
               if (ZRegion(j)==1 && j hasnt door) n++;
           }
           if (n==0) rfalse;
           k=random(n); n=0;
           objectloop (i in compass)
           {   j=p.(i.door_dir);
               if (ZRegion(j)==1 && j hasnt door) n++;
               if (n==k)
               {   move self to j;
                   if (p==location) "^The thief stalks away!";
                   if (j==location) "^The thief stalks in!";
                   rfalse;
               }
           }
       ],
  has  animate;

ZRegion(j) works out what kind of value j is: 1 means `is a valid
object number'.  So the thief walks at random but never via doors,
bridges and the like (because these may be locked or have rules
attached); it's only a first approximation, and in a good game one
should occasionally see the thief do something surprising, such as open
a secret door.  As for the name, note that `The Prince of darkness is a
gentleman. Modo he's called, and Mahu' (William Shakespeare, `King
Lear' III iv).

   *Note Exercise 34: Daemons.


File: inform,  Node: Answer 35,  Next: Answer 36,  Prev: Answer 34,  Up: Answers

Answer to Exercise 35: weight--watching daemon
==============================================

   First define a new property for object weight:

Property weight 10;

(10 being an average sort of weight).  Containers weigh more when they
hold things, so we will need:

[ WeightOf obj t i;
   t = obj.weight;
   objectloop (i in obj) t=t+WeightOf(i);
   return t;
];

Now for the daemon which monitors the player's fatigue:

Object weigher "weigher"
  with number 500,
       time_left 5,
       daemon
       [ w s b bw;
            w=WeightOf(player)-100-player.weight;
            s=self.number; s=s-w; if (s<0) s=0; if (s>500) s=500;
            self.number = s;
            if (s==0)
            {   bw=-1;
                objectloop(b in player)
                    if (WeightOf(b)>bw) { bw=WeightOf(b); w=b; }
                print "^Exhausted with carrying so much, you decide
                    to discard ", (the) w, ": "; <<Drop w>>;
            }
            w=s/100; if (w==self.time_left) rfalse;
            if (w==3) print "^You are feeling a little tired.^";
            if (w==2) print "^You possessions are weighing you down.^";
            if (w==1) print "^Carrying so much weight is wearing you out.^";
            self.time_left = w;
       ];

Notice that items are actually dropped with Drop actions: one of them
might be, say, a wild boar, which would bolt away into the forest when
released.  The daemon tries to drop the heaviest item.  (Obviously a
little improvement would be needed if the game contained, say, an
un-droppable but very heavy ball and chain.)  Now the daemon is going
to run every turn forever, but needs to be started: so put
StartDaemon(weigher); into the game's Initialise routine.

   *Note Exercise 35: Daemons.


File: inform,  Node: Answer 36,  Next: Answer 37,  Prev: Answer 35,  Up: Answers

Answer to Exercise 36: scuttling claws
======================================

   See the next answer.

   *Note Exercise 36: Daemons.


File: inform,  Node: Answer 37,  Next: Answer 38,  Prev: Answer 36,  Up: Answers

Answer to Exercise 37
=====================

Object tiny_claws "sound of tiny claws" thedark
  with article "the",
       name "tiny" "claws" "sound" "of" "scuttling" "scuttle"
            "things" "creatures" "monsters" "insects",
       initial "Somewhere, tiny claws are scuttling.",
       before
       [;  Listen: "How intelligent they sound, for mere insects.";
           Touch, Taste: "You wouldn't want to.  Really.";
           Smell: "You can only smell your own fear.";
           Attack: "They easily evade your flailing about in the dark.";
           default: "The creatures evade you, chittering.";
       ],
       each_turn [; StartDaemon(self); ],
       number 0,
       daemon
       [;  if (location~=thedark) { self.number=0; StopDaemon(self); rtrue; }
           switch(++(self.number))
           {   1: "^The scuttling draws a little nearer, and your breathing
                    grows loud and hoarse.";
               2: "^The perspiration of terror runs off your brow.  The
                    creatures are almost here!";
               3: "^You feel a tickling at your extremities and kick outward,
                    shaking something chitinous off.  Their sound alone
                    is a menacing rasp.";
               4: deadflag=1;
                  "^Suddenly there is a tiny pain, of a hypodermic-sharp fang
                    at your calf.  Almost at once your limbs go into spasm,
                    your shoulders and knee-joints lock, your tongue swells...";
           }
       ];

   *Note Exercise 37: Daemons.


File: inform,  Node: Answer 38,  Next: Answer 39,  Prev: Answer 37,  Up: Answers

Answer to Exercise 38: midnight
===============================

   Either set a daemon to watch for the_time suddenly dropping, or put
such a watch in the game's TimePasses routine.

   *Note Exercise 38: Daemons.


File: inform,  Node: Answer 39,  Next: Answer 40,  Prev: Answer 38,  Up: Answers

Answer to Exercise 39: nightfall and daybreak
=============================================

   A minimal solution is as follows:

Constant SUNRISE  360;  ! i.e., 6 am
Constant SUNSET  1140;  ! i.e., 7 pm
Attribute outdoors;     ! Give this to external locations
Attribute lit;          ! And this to artificially lit ones
Global day_state = 2;
[ TimePasses f obj;
  if (the_time >= SUNRISE && the_time < SUNSET) f=1;
  if (day_state == f) rfalse;
  objectloop (obj)
  {   if (obj has lit) give obj light;
      if (obj has outdoors && obj hasnt lit)
      {   if (f==0) give obj ~light; else give obj light;
      }
  }
  if (day_state==2) { day_state = f; return; }
  day_state = f; if (location hasnt outdoors) return;
  if (f==1) "^The sun rises, illuminating the landscape!";
 "^As the sun sets, the landscape is plunged into darkness.";
];

In the Initialise routine, set the time (using SetTime) and then call
TimePasses to set all the light attributes accordingly.  Note that with
this system, there's no need to set light at all: that's automatic.

   *Note Exercise 39: Daemons.


File: inform,  Node: Answer 40,  Next: Answer 41,  Prev: Answer 39,  Up: Answers

Answer to Exercise 40: mid-air location
=======================================

   Because you don't know what order daemons will run in.  A `fatigue'
daemon which makes the player drop something might come after the
`mid-air' daemon has run for this turn.  Whereas each_turn happens
after daemons and timers have run their course, and can fairly assume
no further movements will take place this turn.

   *Note Exercise 40: Daemons.


File: inform,  Node: Answer 41,  Next: Answer 42,  Prev: Answer 40,  Up: Answers

Answer to Exercise 41: long time-scale game
===========================================

   It would have to provide its own code to keep track of time, and it
can do this by providing a TimePasses() routine.  Providing "time" or
even "date" verbs to tell the player would also be a good idea.

   *Note Exercise 41: Daemons.


File: inform,  Node: Answer 42,  Next: Answer 43,  Prev: Answer 41,  Up: Answers

Answer to Exercise 42: player reacting before
=============================================

   Two reasons.  Firstly, there are times when we want to be able to
trap orders to other people, which react_before does not.  Secondly,
the player's react_before rule is not necessarily the first to react.
In the case of the player's deafness, a cuckoo may have already used
react_before to sing.  But it would have been safe to use
GamePreRoutine, if a little untidy (because a rule about the player
would not be part of the player's definition, which makes for confusing
source code).  See *Note Actions and Reactions:: for the exact sequence
of events when actions are processed.

   *Note Exercise 42: Player.


File: inform,  Node: Answer 43,  Next: Answer 44,  Prev: Answer 42,  Up: Answers

Answer to Exercise 43: silencing player
=======================================

       orders
       [;  if (gasmask hasnt worn) rfalse;
           if (actor==self && action~=##Answer or ##Tell or ##Ask) rfalse;
          "Your speech is muffled into silence by the gas mask.";
       ],

   *Note Exercise 43: Player.


File: inform,  Node: Answer 44,  Next: Answer 45,  Prev: Answer 43,  Up: Answers

Answer to Exercise 44: the player's wayhel
==========================================

   The common man's `wayhel' was a lowly mouse.  Since we think much
more highly of the player:

Object hog "Warthog" Caldera
  with name "wart" "hog" "warthog", description "Muddy and grunting.",
       number 0,
       initial "A warthog snuffles and grunts about in the ash.",
       orders
       [; if (action~=##Go or ##Look or ##Examine)
              "Warthogs can't do anything as tricky as that!";
       ],
  has  animate proper;

and we just ChangePlayer(warthog);.  Note that the same orders routine
applies to the player-as-human typing "warthog, listen" as to the
player-as-warthog typing just "listen".

   *Note Exercise 44: Player.


File: inform,  Node: Answer 45,  Next: Answer 46,  Prev: Answer 44,  Up: Answers

Answer to Exercise 45: Giant with conscience
============================================

      orders
      [;  if (player==self)
          {   if (actor~=self)
                 "You only become tongue-tied and gabble.";
              rfalse;
          }
          Attack: "The Giant looks at you with doleful eyes.
                   ~Me not be so bad!~";
          default: "The Giant is unable to comprehend your instructions.";
      ],

   *Note Exercise 45: Player.


File: inform,  Node: Answer 46,  Next: Answer 47,  Prev: Answer 45,  Up: Answers

Answer to Exercise 46: chessboard of rooms
==========================================

   Give the "chessboard" room a short_name routine (it probably already
has one, to print names like "Chessboard d6") and make it change the
short name to "the gigantic Chessboard" if and only if action is
currently set to ##Places.

   *Note Exercise 46: Constants and Scoring.


File: inform,  Node: Answer 47,  Next: Answer 48,  Prev: Answer 46,  Up: Answers

Answer to Exercise 47: varying the prompt
=========================================

   Put the following definition between inclusion of "Parser" and
"Verblib":

     Object LibraryMessages
       with before
            [;  Prompt: if (turns==1)
                        print "What should you, the detective, do now?^>";
                    else
                        print "What next?^>";
                    rtrue;
            ];

   *Note Exercise 47: Extending the Library.


File: inform,  Node: Answer 48,  Next: Answer 49,  Prev: Answer 47,  Up: Answers

Answer to Exercise 48
=====================

   The details are left to the reader.  One must provide a new grammar
file (generating the same actions but from different syntax) and a very
large LibraryMessages object.  Translations have been made, with some
success, into Spanish, German, French and Italian: at present quite
some work is required, but LibraryMessages is a start.

   *Note Exercise 48: Extending the Library.


File: inform,  Node: Answer 49,  Next: Answer 50,  Prev: Answer 48,  Up: Answers

Answer to Exercise 49: printing pronouns
========================================

   Simply define the following (for accusative, nominative and
capitalised nominative pronouns, respectively):

[ PronounAcc i;
    if (i hasnt animate) print "it";
    else { if (i has female) print "her"; else print "him"; } ];
[ PronounNom i;
    if (i hasnt animate) print "it";
    else { if (i has female) print "she"; else print "he"; } ];
[ CPronounNom i;
    if (i hasnt animate) print "It";
    else { if (i has female) print "She"; else print "He"; } ];

   *Note Exercise 49: Describing Objects.


File: inform,  Node: Answer 50,  Next: Answer 51,  Prev: Answer 49,  Up: Answers

Answer to Exercise 50: ornate box (inventory inside)
====================================================

   Use the invent routine to signal to short_name and article routines
to change their usual habits:

       invent
       [;  if (inventory_stage==1) give self general;
           else give self ~general;
       ],
       short_name
       [;  if (self has general) { print "box"; rtrue; } ],
       article
       [;  if (self has general) { print "that hateful"; rtrue; }
           else print "a"; ],

   *Note Exercise 50: Describing Objects.


File: inform,  Node: Answer 51,  Next: Answer 52,  Prev: Answer 50,  Up: Answers

Answer to Exercise 51: very verbose mode
========================================

   This answer is cheating, as it needs to know about the library's
lookmode variable (set to 1 for normal, 2 for verbose or 3 for
superbrief).  Simply include:

[ TimePasses;
  if (action~=##Look && lookmode==2) <Look>;
];

   *Note Exercise 51: Describing Objects.


File: inform,  Node: Answer 52,  Next: Answer 53,  Prev: Answer 51,  Up: Answers

Answer to Exercise 52: double inventory
=======================================

[ DoubleInvSub i count1 count2;
  print "You are carrying ";
  objectloop (i in player)
  {   if (i hasnt worn) { give i workflag; count1++; }
      else { give i ~workflag; count2++; }
  }
  if (count1==0) print "nothing.";
  else
  WriteListFrom(child(player),
      FULLINV_BIT + ENGLISH_BIT + RECURSE_BIT + WORKFLAG_BIT);

  if (count2==0) ".";
  print ".  In addition, you are wearing ";
  objectloop (i in player)
  {   if (i hasnt worn) give i ~workflag; else give i workflag;
  }
  WriteListFrom(child(player),
      ENGLISH_BIT + RECURSE_BIT + WORKFLAG_BIT);
  ".";
];

   *Note Exercise 52: Listing Objects.


File: inform,  Node: Answer 53,  Next: Answer 54,  Prev: Answer 52,  Up: Answers

Answer to Exercise 53: Scrabble pieces
======================================

Class Letter
  with list_together
       [; if (inventory_stage==1)
          { print "the letters ";
            if (~~(c_style & ENGLISH_BIT))   c_style = c_style + ENGLISH_BIT;
            if (~~(c_style & NOARTICLE_BIT)) c_style = c_style + NOARTICLE_BIT;
            if (c_style & NEWLINE_BIT)       c_style = c_style - NEWLINE_BIT;
            if (c_style & INDENT_BIT)        c_style = c_style - INDENT_BIT;
          }
          else print " from a Scrabble set";
       ],
       short_name
       [;  if (listing_together ofclass Letter) rfalse;
           print "letter ", (object) self, " from a Scrabble set"; rtrue;
       ],
       article "the";

and then as many letters as desired, along the lines of

Letter -> "X" with name "x";

   *Note Exercise 53: Listing Objects.


File: inform,  Node: Answer 54,  Next: Answer 55,  Prev: Answer 53,  Up: Answers

Answer to Exercise 54: three denominations of coin
==================================================

Class  Coin
  with name "coin",
       description "A round unstamped disc, presumably local currency.",
       parse_name
       [ i j w;
         if (parser_action==##TheSame)
         {   if ((parser_one.&name)-->0 == (parser_two.&name)-->0) return -1;
             return -2;
         }
         w=(self.&name)-->0;
         for (::i++)
         {   j=NextWord();
             if (j=='coins') parser_action=##PluralFound;
             else if (j~='coin' or w) return i;
         }
       ],
       list_together "coins",
       plural
       [;  print (string) (self.&name)-->0;
           if (~~(listing_together ofclass Coin)) print " coins";
       ],
       short_name
       [;  if (listing_together ofclass Coin)
           {   print (string) (self.&name)-->0; rtrue; }
       ],
       article
       [;  if (listing_together ofclass Coin) print "one"; else print "a";
       ],
  has  is_coin;
Class  Gold_coin   class Coin with name "gold";
Class  Silver_coin class Coin with name "silver";
Class  Bronze_coin class Coin with name "bronze";
SilverCoin -> "silver coin";
... and so on

   *Note Exercise 54: Listing Objects.


File: inform,  Node: Answer 55,  Next: Answer 56,  Prev: Answer 54,  Up: Answers

Answer to Exercise 55: I Ching coins
====================================

   For brevity, the following answer omits the routines:
CoinsTogether(attr) which finds if the three coins with this attr
(is_gold or is_silver) are together, returning 0 if they aren't and
otherwise the object of which they are children; and Trigram(attr)
which prints out the trigram currently showing on the coins of that
attr, e.g., "Tails, Tails, Heads (Chen)".

[ Face x; if (x.face_up==1) print "Heads"; else print "Tails"; ];
[ CoinsLT whichclass k i c;
  if (inventory_stage == 1)
  {   if (whichclass == GoldChing) print "the gold"; else print "the silver";
      print " coins ";
      k=CoinsTogether(whichclass);
      if (k==location)
      {   objectloop(i ofclass whichclass)
          {   print (name) i;
              switch(++c)
              {  1: print ", "; 2: print " and ";
                 3: print " (showing the trigram ", (Trigram) whichclass, ")";
              }
          }
          rtrue;
      }
      if (~~(c_style & ENGLISH_BIT))   c_style = c_style + ENGLISH_BIT;
      if (~~(c_style & NOARTICLE_BIT)) c_style = c_style + NOARTICLE_BIT;
      if (c_style & NEWLINE_BIT)       c_style = c_style - NEWLINE_BIT;
      if (c_style & INDENT_BIT)        c_style = c_style - INDENT_BIT;
  }
  rfalse;
];
Class  Ching
  with face_up 1, article "the",
       parse_name
       [ i j w;
         if (parser_action==##TheSame) return -2;
         w='gold'; if (self ofclass SilverChing) w='silver';
         for (::i++)
         {   j=NextWord();
             if (j=='coins') parser_action=##PluralFound;
             else if (j~='coin' or w or self.name) return i;
         }
       ],
       after
       [ j;  Drop, PutOn:
                 self.face_up=random(2); print (Face) self, ". ";
                 if (self ofclass GoldChing) j=GoldChing; else j=SilverChing;
                 if (CoinsTogether(j)~=0)
                 {   print "The ";
                     if (j==GoldChing) print "gold"; else print "silver";
                     print_ret " trigram is now ", (Trigram) j, ".";
                 }
                 new_line; rtrue;
       ];
Class  GoldChing class Ching
  with list_together [; return CoinsLT(GoldChing); ];
Class  SilverChing class Ching
  with list_together [; return CoinsLT(SilverChing); ];
...
GoldChing -> goat "goat"       with name "goat";
GoldChing -> deer "deer"       with name "deer";
GoldChing -> chicken "chicken" with name "chicken";
SilverChing -> robin "robin"   with name "robin";
SilverChing -> snake "snake"   with name "snake";
SilverChing -> bison "bison"   with name "bison";

There are two unusual points here.  Firstly, the CoinsLT routine is not
simply given as the common list_together value in the coin class since,
if it were, all six coins would be grouped together: we want two groups
of three, so the gold and silver coins have to have different
list_together values.  Secondly, if a trigram is together and on the
floor, it is not good enough to simply append text like "showing Tails,
Heads, Heads (Tui)" at inventory_stage 2 since the coins may be listed
in a funny order: for example, in the order snake, robin, bison.  In
that event, the order the coins are listed in doesn't correspond to the
order their values are listed in, which is misleading.  So instead
CoinsLT takes over entirely at inventory_stage 1 and prints out the
list of three itself, returning true to stop the list from being
printed out by the library as well.

   *Note Exercise 55: Listing Objects.


File: inform,  Node: Answer 56,  Next: Answer 57,  Prev: Answer 55,  Up: Answers

Answer to Exercise 56: tomato in red or green
=============================================

parse_name
[ i j w; if (self has general) j='red'; else j='green';
         w=NextWord();
         while (w==j or 'fried')
         {   w=NextWord(); i++;
         }
         if (w=='tomato') return i+1;
         return 0;
],

   *Note Exercise 56: Parsing Nouns.


File: inform,  Node: Answer 57,  Next: Answer 58,  Prev: Answer 56,  Up: Answers

Answer to Exercise 57: the artiste formerly known as Princess
=============================================================

Object -> princess "/?%?/ (the artiste formerly known as Princess)"
  with name "princess" "artiste" "formerly" "known" "as",
       short_name
       [;   if (self hasnt general) { print "Princess"; rtrue; }
       ],
       parse_name
       [ x; if (self hasnt general)
            {   if (NextWord()=='princess') return 1;
                return 0;
            }
            x=WordAddress(wn);
            if (   x->0 == '/' && x->1 == '?' && x->2 == '%'
                && x->3 == '?' && x->4 == '/') return 1;
            return -1;
       ],
       react_before
       [;  Listen: if (noun==0)
               print_ret (name) self, " sings a soft siren song.";
       ],
       life
       [;  Kiss: give self general; self.life = NULL;
              "In a fairy-tale transformation, the Princess
               steps back and astonishes the world by announcing
               that she will henceforth be known as ~/?%?/~.";
       ],
  has  animate proper female;

   *Note Exercise 57: Parsing Nouns.


File: inform,  Node: Answer 58,  Next: Answer 59,  Prev: Answer 57,  Up: Answers

Answer to Exercise 58: drinks machine
=====================================

   Something to note here is that the button can't be called just
"coffee" when the player's holding a cup of coffee: this means the game
responds sensibly to the sequence "press coffee" and "drink coffee".
Also note the way itobj is set to the delivered drink, so that "drink
it" works nicely.

Object -> drinksmat "drinks machine",
  with name "drinks" "machine",
       initial
          "A drinks machine here has buttons for Cola, Coffee and Tea.",
  has  static;
Object -> thebutton "drinks machine button"
  has  scenery
 with  parse_name
       [ i flag type;
            for (: flag == 0: i++)
            {   flag = 1;
                switch(NextWord())
                {   'button', 'for': flag = 0;
                    'coffee': if (type == 0) { flag = 0; type = 1; }
                    'tea':    if (type == 0) { flag = 0; type = 2; }
                    'cola':   if (type == 0) { flag = 0; type = 3; }
                }
            }
            if (type==drink.number && i==2 && type~=0 && drink in player)
                return 0;
            self.number=type; return i-1;
        ],
        number 0,
        before
        [; Push, SwitchOn:
             if (self.number == 0)
                "You'll have to say which button to press.";
             if (parent(drink) ~= 0) "The machine's broken down.";
             drink.number = self.number; move drink to player; itobj = drink;
             print_ret "Whirr!  The machine puts ", (a) drink, " into your \
                 glad hands.";
           Attack: "The machine shudders and squirts cola at you.";
           Drink:  "You can't drink until you've worked the machine.";
        ];
Object  drink "drink"
  with  parse_name
        [ i flag type;
            for (: flag == 0: i++)
            {   flag = 1;
                switch(NextWord())
                {   'drink', 'cup', 'of': flag = 0;
                    'coffee': if (type == 0) { flag = 0; type = 1; }
                    'tea':    if (type == 0) { flag = 0; type = 2; }
                    'cola':   if (type == 0) { flag = 0; type = 3; }
                }
            }
            if (type ~= 0 && type ~= self.number) return 0;
            return i-1;
        ],
        short_name
        [;  print "cup of ";
            switch (self.number)
            { 1: print "coffee"; 2: print "tea"; 3: print "cola"; }
            rtrue;
        ],
        number 0,
        before
        [; Drink: remove self;
            "Ugh, that was awful.  You crumple the cup and responsibly \
             dispose of it.";
        ];

   *Note Exercise 58: Parsing Nouns.

